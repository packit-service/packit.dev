[
{
	"uri": "https://packit.dev/docs/actions/",
	"title": "Actions",
	"tags": [],
	"description": "",
	"content": " You can probably find yourself in a situation where some part of the packit workflow needs to be tweaked for your package.\nPackit supports actions, a way to change default implementation for a command of your choice. Packit is able to execute more commands. Each action can accept list of commands.\nAll the actions are also executed inside Packit-as-a-Service. The service creates a new sandbox environment where the command is ran.\nActions have a default behaviour which you can override, hooks don\u0026rsquo;t have any - hooks are a way for you to perform operations after packit does a specific event, e.g. clones an upstream repo.\nCurrently, these are the actions you can use:\npropose-update command     name working directory when run description     [hook] post-upstream-clone upstream git repo after cloning of the upstream repo (master) and before other operations    [hook] pre-sync upstream git repo after cloning and checkout to the correct (release) branch     prepare-files upstream git repo after cloning, checking out of both upstream and dist-git repos replace patching and archive generation    create-patches upstream git repo after sync of upstream files to the downstream replace patching    create-archive upstream git repo when the archive needs to be created replace the code for creating an archive    get-current-version upstream git repo when the current version needs to be found expect version as a stdout    Creating SRPM These applies to srpm command and building in COPR.\n    name working directory when run description     [hook] post-upstream-clone upstream git repo after cloning of the upstream repo (master) and before other operations     get-current-version upstream git repo when the current version needs to be found expect version as a stdout    create-archive upstream git repo when the archive needs to be created replace the code for creating an archive    create-patches upstream git repo after sync of upstream files to the downstream replace patching    In your package config they can be defined like this:\nspecfile_path: package.spec synced_files: - packit.yaml - package.spec upstream_project_name: package downstream_package_name: package dist_git_url: https://src.fedoraproject.org/rpms/package.git actions: prepare-files: \u0026quot;make prepare\u0026quot; create-archive: - \u0026quot;make archive\u0026quot; - \u0026quot;ls\u0026quot;  "
},
{
	"uri": "https://packit.dev/docs/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": " Actions Architecture Configuration for packit How to source-git? Packit CLI  "
},
{
	"uri": "https://packit.dev/posts/packit-010/",
	"title": "Initial version (0.1.0) of packit is out!",
	"tags": [],
	"description": "",
	"content": "We would like to announce general availability of the initial version of packit, titled \u0026lsquo;0.1.0\u0026rsquo;.\nSince this is our first release, we would like to ask you to be patient if you encounter any issues. We work hard on packit\u0026rsquo;s usability. If you feel like that packit is doing something weird or if anything is unclear, don\u0026rsquo;t hesitate and reach out to us by creating a new Github issue.\nThe initial release contains two commands:\n packit propose-update — Opens a pull request in dist-git for the latest upstream release of a selected repository. packit watch-releases — Watches events for all the upstream releases and performs propose-update for those who use packit.  Installation $ dnf install --enablerepo=updates-testing packit  Or\n$ pip3 install --user packitos  Or (if you\u0026rsquo;re brave)\n$ pip3 install --user git+https://github.com/packit-service/packit  Requirements Present features have strict requirements on the upstream projects:\n You need to have a packit config file present in the upstream repo.\n You need to have spec file present in the upstream repo.\n  This workflow is suitable for people who are both upstream and downstream maintainers of the particular project. If you don\u0026rsquo;t fit into that bucket, then packit might not be ready for you, yet. Please wait till we land more source-git related functionality into packit.\npropose-update I\u0026rsquo;m going to demonstrate this functionality on ogr, our library for git forges, which powers packit.\nIt was recently approved for Fedora, so we can use packit to bring the initial version of ogr into Fedora Rawhide, 30 and 29.\nDo we have everything? Let\u0026rsquo;s see guide for the propose-update command on what we need:\n0. The upstream repository with a valid upstream release. $ git remote -v origin git@github.com:TomasTomecek/ogr.git (fetch) origin git@github.com:TomasTomecek/ogr.git (push) upstream https://github.com/packit-service/ogr.git (fetch) upstream https://github.com/packit-service/ogr.git (push)  Yup.\n$ git tag --list 0.0.1 0.0.2 0.0.3 $ git checkout 0.0.3 Note: checking out '0.0.3'.  And the tag name is matching the version in a spec file:\n$ grep Version python-ogr.spec Version: 0.0.3  1. Packit config file placed in the upstream repository. $ ll .packit.yaml -rw-rw-r--. 1 tt tt 177 Mar 1 17:44 .packit.yaml  Check.\n2. Spec file present in the upstream repository. $ ll python-ogr.spec -rw-rw-r--. 1 tt tt 1.3K Mar 1 17:43 python-ogr.spec  :+1:\n3. Pagure API tokens for Fedora Dist-git. $ env | grep TOKEN PAGURE_USER_TOKEN=will PAGURE_FORK_TOKEN=not GITHUB_TOKEN=share, sorry  4. Valid Fedora Kerberos ticket. $ kinit ttomecek@FEDORAPROJECT.ORG Password for ttomecek@FEDORAPROJECT.ORG: $ klist Ticket cache: KEYRING:persistent:1024:krb_ccache_g0t1Ty3Ah Default principal: ttomecek@FEDORAPROJECT.ORG Valid starting Expires Service principal 03/01/2019 18:12:25 03/02/2019 18:12:19 krbtgt/FEDORAPROJECT.ORG@FEDORAPROJECT.ORG renew until 03/08/2019 18:12:19  We\u0026rsquo;re all set!\nTime to shine We are still in the \u0026ldquo;ogr\u0026rdquo; upstream git repository.\n$ packit propose-update INFO: Running 'anitya' versioneer ERROR: Failed to determine latest upstream version! Check that the package exists on https://release-monitoring.org. using \u0026quot;master\u0026quot; dist-git branch syncing ./python-ogr.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.0.3.tar.gz 100%[=============================\u0026gt;] 17.95K eta 00:00:00 downloaded archive: /tmp/tmp2e65b0xt/ogr-0.0.3.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/1  Mind-blowing, isn\u0026rsquo;t it? Now we have latest python-ogr in Fedora Rawhide by running only a single command.\nI have also added ogr into release-monitoring as packit suggests.\nOnce we are okay with the changes, we have to merge the pull request. That\u0026rsquo;s our responsibility, as maintainers.\nBuilding in koji Time to build the package (packit doesn\u0026rsquo;t support building in koji, yet)\n$ fedpkg clone python-ogr Cloning into 'python-ogr'... remote: Counting objects: 8, done. remote: Compressing objects: 100% (5/5), done. remote: Total 8 (delta 0), reused 5 (delta 0) Receiving objects: 100% (8/8), done. $ cd python-ogr $ git log commit c298df5e540ba1d010366e102c1c75d4f5b0b0cc (HEAD -\u0026gt; master, origin/master, origin/HEAD) Author: Tomas Tomecek \u0026lt;ttomecek@redhat.com\u0026gt; Date: Fri Mar 1 18:15:00 2019 +0100 [packit] 0.0.3 upstream release more info Signed-off-by: Tomas Tomecek \u0026lt;ttomecek@redhat.com\u0026gt; commit 7d5ab1471ca0ee2a6c0254410b83beaa83b80f0b Author: Gwyn Ciesla \u0026lt;limb@fedoraproject.org\u0026gt; Date: Fri Mar 1 15:18:34 2019 +0000 Added the README  Yup, that\u0026rsquo;s our commit. more info was added there by accident, this is already fixed in packit.\n$ fedpkg build Building python-ogr-0.0.3-1.fc31 for rawhide Created task: 33125435 Task info: https://koji.fedoraproject.org/koji/taskinfo?taskID=33125435 Watching tasks (this may be safely interrupted)... 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): free 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): free -\u0026gt; open (buildvm-14.phx2.fedoraproject.org) 33125451 buildArch (python-ogr-0.0.3-1.fc31.src.rpm, noarch): open (buildvm-14.phx2.fedoraproject.org) 33125436 buildSRPMFromSCM (/rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): closed 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): open (buildvm-14.phx2.fedoraproject.org) -\u0026gt; closed 0 free 1 open 2 done 0 failed 33125464 tagBuild (noarch): closed 33125451 buildArch (python-ogr-0.0.3-1.fc31.src.rpm, noarch): open (buildvm-14.phx2.fedoraproject.org) -\u0026gt; closed 0 free 0 open 4 done 0 failed 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc) completed successfully  That was rough, can\u0026rsquo;t wait to do this with packit.\nLet\u0026rsquo;s do Fedora 30 now:\n$ packit propose-update --dist-git-branch f30 INFO: Running 'anitya' versioneer using \u0026quot;f30\u0026quot; dist-git branch syncing ./python-ogr.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.0.3.tar.gz 100%[=============================\u0026gt;] 17.95K eta 00:00:00 downloaded archive: /tmp/tmpl5xxq22x/ogr-0.0.3.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/3  And so on\u0026hellip;\nConclussion As you can see, packit is useful for us right away.\nWe\u0026rsquo;ll be delighted if you try it out and let us know what you think.\n"
},
{
	"uri": "https://packit.dev/docs/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://packit.dev/packit-as-a-service/",
	"title": "Packit-as-a-Service",
	"tags": [],
	"description": "",
	"content": " Packit-as-a-Service is a GitHub App that helps you continuously ensure that your project work in Fedora OS.\nEasy to use Using Packit Service is very straightforward: add one config file to your repository together with the RPM spec file and you\u0026rsquo;re good to go.\nPackit Service validates your pull requests by building your software in Fedora OS. Once the builds are done, Packit lets you know how to install the RPMs inside your environment so you can try the changes before merging them.\nPackit is also available as a CLI tool, so you can always try things locally on your own.\nIntegrating Packit-as-a-Service into your project or organization from GitHub Marketplace  Go to GitHub Marketplace In section Continuous integration find \u0026ldquo;Packit-as-a-Service\u0026rdquo; and select it On the \u0026ldquo;Packit-as-a-Service\u0026rdquo; page, under \u0026ldquo;Pricing and setup\u0026rdquo;, click \u0026ldquo;Install it for free\u0026rdquo; Click \u0026ldquo;Complete order and begin installation\u0026rdquo; Install the \u0026ldquo;Packit-as-a-Service\u0026rdquo; on all repositories or to certain repositories  Once installed, you will see the \u0026ldquo;Packit-as-a-Service\u0026rdquo; GitHub application in your project settings. In the left sidebar, click \u0026ldquo;Integration \u0026amp; services\u0026rdquo; and you will see the application displayed there.\nAdd .packit.yaml configuration file Packit Service expects the \u0026ldquo;.packit.yaml\u0026rdquo; configuration file in root of your upstream repository. For more info, see .packit.yaml documentation.\nAdd RPM spec file Packit Service needs the RPM spec file to build your project.\nEither include it in your upstream repository or if you do not want to have it in your upstream repository, see section RPM spec file not in upstream\nHow to check Packit Service works in your project? Currently, Packit Service is able only to build your changes and provide them as RPMs. Once you create a pull request, Packit Service builds the code from the pull request in COPR repository and reports back COPR build status to the pull request.\nAn example of Packit Service pull request:\nHow to re-trigger Packit Service actions in your pull request? Packit Service is able to trigger a pull request comments and reacts on them. If you want to test the pull request is still buildable by Packit Service in COPR repository, add a comment /packit copr-build into your pull request and Packit Service triggers it and builds the code from the pull request in COPR repository.\nOnly project collaborators can re-trigger actions.\n"
},
{
	"uri": "https://packit.dev/posts/packit-020/",
	"title": "Packit 0.2.0 is here!",
	"tags": [],
	"description": "",
	"content": "Our sprint nears an end which means we have released a new version of packit - 0.2.0! You can expect a new release after every sprint (i.e. every 2 weeks).\nThe 0.2.0 version has a bunch of new features and improvements: you can find a complete list in the changelog. We also have a detailed documentation for all the workflows packit covers.\nLet\u0026rsquo;s get through what\u0026rsquo;s new:\n We have decided to rename two keys in our config file so they are more descriptive. Old names still work but they are deprecated:  package_name → downstream_package_name upstream_name → upstream_project_name  You don\u0026rsquo;t need to touch dist-git at all when getting your new upstream release into Fedora, you can stay in your upstream repository and just fire off a bunch of packit calls:  packit propose-update to create a pull request in Fedora dist-git with the selected upstream release packit build to build the new upstream release once the pull request is merged and finally, packit create-update creates a new bodhi update (if you chose a stable Fedora release)  Packit now has a srpm command which creates an SRPM out of the local content of your upstream repository. You can now use packit to sync files from your dist-git repo back into upstream (mainly to keep spec files in sync). sync-from-downstream is the command. Command propose-update received numerous improvements:  You can pick upstream version to use. Packit will NOT check out the git ref with the upstream release if you specify --local-content It\u0026rsquo;s possible to force packit to execute fedpkg new-sources using --force-new-sources and bypass the caching mechanism.   Installation Please make sure you are installing 0.2.0:\n$ dnf install --enablerepo=updates-testing packit  Or\n$ pip3 install --user packitos  You can also install packit from master branch, if you are brave enough:\n$ pip3 install --user git+https://github.com/packit-service/packit  How are we using packit? I\u0026rsquo;d like to show you how we used packit to bring a new upstream release of ogr into Fedora, a library which packit is using.\nOnce we have performed an upstream release of ogr, we can propose an update in dist-git:\n$ git clone https://github.com/packit-service/ogr \u0026amp;\u0026amp; cd ogr/ $ packit propose-update INFO: Running 'anitya' versioneer Version in upstream registries is '0.0.3'. Version in spec file is '0.0.3'. Picking version of the latest release from the upstream registry over spec file. Checking out upstream version 0.0.3 Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpb9xlvdhj Syncing /home/tt/g/user-cont/ogr/python-ogr.spec Archive ogr-0.0.3.tar.gz found in lookaside cache (skipping upload). ERROR Cmd('git') failed due to: exit code(1) cmdline: git commit -s -m [packit] 0.0.3 upstream release -m Upstream tag: 0.0.3 Upstream commit: 059d21080a7849acff4626b6e0ec61830d537ac4 stdout: 'On branch 0.0.3-master-update nothing to commit, working tree clean'  Whoops, it seems that I have messed up, I forgot to bump the spec file in the upstream repo when doing the release. I will bump it locally and utilize --local-content argument:\n$ rpmdev-bumpspec -n 0.1.0 -c 'New upstream release: 0.1.0' *.spec $ packit propose-update --local-content INFO: Running 'anitya' versioneer Version in upstream registries is '0.0.3'. Version in spec file is '0.1.0'. Picking version of the latest release from the upstream registry over spec file. Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpd9j4se27 Syncing /home/tt/g/user-cont/ogr/python-ogr.spec Archive ogr-0.1.0.tar.gz found in lookaside cache (skipping upload). INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.1.0.tar.gz 100%[=============================\u0026gt;] 20.25K eta 00:00:00 Downloaded archive: '/tmp/tmpd9j4se27/ogr-0.1.0.tar.gz' About to upload to lookaside cache won't be doing kinit, no credentials provided PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/6  Once the scratch build is done and tests passed we merged and built it:\n$ packit build Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmprp3cmdjy Building python-ogr-0.1.0-1.fc31 for rawhide Created task: 33616980 Task info: https://koji.fedoraproject.org/koji/taskinfo?taskID=33616980  We have done the same for F30 and F29.\nThe previous commands were ran in the directory of the upstream repository. Packit also accepts path to your upstream clone, or even URL. So let\u0026rsquo;s create a bodhi update for python-ogr by specifying the upstream repo URL:\n$ cd $HOME $ packit create-update --dist-git-branch f29 https://github.com/packit-service/ogr Cloning repo: https://github.com/packit-service/ogr -\u0026gt; /tmp/tmpdkdadmn_ Koji builds for package python-ogr and koji tag f29-updates-candidate: - python-ogr-0.1.0-1.fc29 Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpn1809ec9 Bodhi update FEDORA-2019-78948e62d2: - https://bodhi.fedoraproject.org/updates/FEDORA-2019-78948e62d2 - stable_karma: 3 - unstable_karma: -3 - notes: New upstream release: 0.1.0  And that\u0026rsquo;s it, no need to access dist-git any more.\nPlease give packit a try and let us know what you think.\n"
},
{
	"uri": "https://packit.dev/posts/",
	"title": "Blog Posts",
	"tags": [],
	"description": "",
	"content": " Packit 0.1.0 Packit 0.2.0 Packit 0.3.0 Packit 0.4.0 \u0026amp; 0.4.1  "
},
{
	"uri": "https://packit.dev/posts/packit-030/",
	"title": "Packit 0.3.0",
	"tags": [],
	"description": "",
	"content": "In the previous post we promised to provide a new release every 2 weeks and we are already breaking this promise as it\u0026rsquo;s been 3 weeks since then. We decided to wait with the release to merge several pull requests related to source-git support.\nNow the good news. You can find a complete list of new features and improvements of version 0.3.0 in the changelog.\nFeatures  You can now specify your own hooks or actions to replace default packit behaviour. (More information can be found in the documentation). Packit supports pagure.io-based upstream projects. Commands propose-update and sync-from-downstream supports copying directories. A new command status! It displays useful upstream/downstream info. Packit now supports Source-git. The functionality is not available, yet - we will add a CLI interface for it in the next release. You can now have a config file for packit in your home directory(~/.config/packit.yaml). Packit installed from an RPM now has manpages.  packit status example $ packit status Cloning repo: https://src.fedoraproject.org/rpms/packit.git -\u0026gt; /tmp/tmp84we_6n8 Downstream PRs: No open PRs. f29: 0.2.0 f30: 0.2.0 master: 0.2.0 "
},
{
	"uri": "https://packit.dev/docs/cli/build/",
	"title": "build",
	"tags": [],
	"description": "",
	"content": " Submit a koji build for the selected branch in Fedora dist-git.\nRequirements  Upstream git repository on Github. Packit config file placed in the upstream repository. Valid Fedora Kerberos ticket.  Tutorial  Place a config file for packit in the root of your upstream repository.\n The command below would perform fedpkg build in the Fedora dist-git master branch.\n$ cd my/ustream/project/ $ packit build   Help Usage: packit build [OPTIONS] [PATH_OR_URL] Build selected upstream project in Fedora. Packit goes to dist-git and performs `fedpkg build` for the selected branch. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Target branch in dist-git to release into. --dist-git-path TEXT Path to dist-git repo to work in. Otherwise clone the repo in a temporary directory. --scratch Submit a scratch koji build -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/posts/packit-041/",
	"title": "Packit 0.4.0 &amp; 0.4.1",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s been over a month since we released packit \u0026ldquo;0.3.0\u0026rdquo;. Here comes packit 0.4.0 (and patch release 0.4.1) and as always they bring a lot of new features and improvements.\nYou can find a complete list in the changelog.\nPackit as a service  We have Packit as a service running in OpenShift and also a GitHub App, which uses it. Unfortunately it\u0026rsquo;s still not in the Marketplace, so we have been the only one using it so far. The service/app submits builds in copr and once they\u0026rsquo;re done it adds a GitHub status and comment with instructions how to install the builds. The service is now configurable via jobs defined in configuration file. Packit is now able to check GPG signatures of the upstream commits against configured fingerprints.  CLI  srpm command now works also with Source-git. status command now access remote APIs asynchronously in parallel, which should speed up the execution. CLI has new --dry-run option to not perform any remote changes (pull requests or comments). Fedmsg parsing has been unified into a single listen-to-fedmsg command. "
},
{
	"uri": "https://packit.dev/source-git/",
	"title": "Source-git",
	"tags": [],
	"description": "",
	"content": "Source git is the place where the manual work is done This document serves as a detailed description of source-git. Please bear in mind that some things are a subject to change — the overall design is pretty solid, but details may be tinkered over time.\nAuthors: Stef Walter, Tomas Tomecek\nTL;DR Content of source-git repository is equivalent to dist-git, but uses upstream format: source files instead of tarballs, git commits instead of patches.\nYou can host this repository, or the specific git branch, anywhere you want. If you open a pull request, you will receive feedback on the changes:\n Does the package build with the changes? Do all the package tests pass? How about tests of the dependant packages? Are the changes good to be included in Fedora?  The goal of packit is to provide automation and tooling to interact with source-git repositories so you don\u0026rsquo;t have to touch dist-git ever again. Our plan is to center development experience around upstream repositories and source-git.\nUpstream repositories and source-git repositories are pretty much the same thing. Creating source-git only makes sense when the upstream does not accept downstream spec file or adding spec file to such a project doesn\u0026rsquo;t make sense.\nFull description Source git becomes the place for creative and interesting work, including aspects of packaging requiring human effort. We allow dist-git to become an auto-maintained location, used for tracking the current state of Fedora, rather than the place where any actual development happens.\nBecause source git is the location for creative work, we can use modern tooling, GitHub, GitLab, Pagure, pull requests, code review, continuous integration and other modern development workflows.\nIn many cases source git can be the upstream project git itself (mostly with projects where downstream maintainer is also the upstream maintainer). In other cases source git can be a fork of upstream git (such as with the Linux kernel).\nWe take cues from projects that already do this. We use the distributed nature of git repositories to overcome obstacles where certain parts of a package (patches, spec, tests) can not (due to embargoes/secrets) or will not (due the upstream project) be included in the upstream source git.\nBots are perfect candidates to perform the mundane tasks of auto-maintaining dist-git. Whenever a bot gets stuck, it can always ask maintainer for help (or the maintainer can perform the action for the bot).\nPremises One of the fundamentally useless manual activities when a maintaining a package in Fedora is moving code from one git repository format to another. a) git is distributed b) dist-git content is mostly boilerplate or regurgitated data.\nLinux distributions gain an advantage from having patches incorporated upstream and not carrying them downstream.\nHuman effort should not be focused on repetitive automatible tasks related to churn and moving code around.\nDist-git is used as a store of state for build tools (like koji). Reinventing dist-git itself fundamentally, means reinventing a lot of tooling.\nPrinciples Dist-git tracks the inputs for and source state of a package build in Fedora. It is not a place for development. It is the place where integration happens.\nA Dist-git branch may diverge from the stable state of a Fedora release. The stable state is represented by which builds were tagged into the stable compose, not by what is in dist-git.\nAim to do Fedora development of a package in source git. Either directly in upstream or in downstream git forks and branches of the upstream (see the kernel for longest running example of this).\nAny repetitive task, whether repetitive for a single package, or repetitive across packages should be owned by bots auto-maintaining dist-git. Any creative non-automatable human task should be done in source git.\nWe are starting this project open source from the beginning.\nAcceptance Criteria In the ideal path, dist-git should be completely automatically “maintained” (already done to varying extents in the kernel, systemd, cockpit, ostree, conu, colin and other packages).\nIt must be trivially possible to opt in and out of auto-maintenance for a given dist-git branch.\nIt should continue to be possible for a human to fix up a dist-git branch, in cases where a task was done incorrectly by a bot. Bots may overwrite such fixups.\nEach auto-maintained dist-git branch tracks a branch in a source git repository. The source git branch should share a common git history with the upstream project branches if maintainer desires such functionality.\nEach time the HEAD of the git source branch changes, a process is started to update dist-git to reflect those changes. This process may also be triggered manually via a tool. If the dist-git is not in an expected state (last commit is not from the bot), the bot should report such divergence.\nOnly the most recent signed commit is a candidate for pulling into dist-git.\nSource code and patches are pulled from source git branch:\n The source code is the git source branch itself. The latest git tag of the git source branch is treated as the release. It must be possible to ignore certain tag patterns. Any commits after that tag in the git source branch are treated as additional patches to be distributed. In order to turn it into an SRPM and include it into dist-git it may be automatically turned into a tarball via an archive command on its latest tag. It must also be possible to use released tarballs from a project if available and necessary for a given dist-git repository, and layer patch files on top in dist-git.  Spec files are pulled from source:\n In the ideal case a spec file is maintained upstream in the same git repository as the source code. This is similar to how many projects have a Dockerfile. When upstream does not accept a spec file, it should be placed as an additional commit in the source git branch, and carried as if it were a patch. To allow trivial revert, review and merge workflows, the release number of the spec file is automatically generated (eg: SuSE and OBS). The release number should be present in the SRPM file name and contents. %changelog in an SRPM is automatically generated from the commits in source git repository. Various techniques may be used to collapse history. Project specific tooling in the source git repo can be used to generate the spec file (eg: as seen today in the kernel). We must provide reference implementation of such script. A spec file can be auto-generated for new packages, and reviewed by a human, who can do FIXUPs.  See: https://github.com/clearlinux/autospec   Tests are pulled from source:\n Components of the operating system have integration and acceptance tests. In the ideal case these are maintained upstream in the given project. They are treated similar to source code. When an upstream does not accept a test, it should be placed as an additional commit in the branch of the git source repository, and carried as if it was a patch. Tests should be wrapped in such a way that anyone can easily (2 commands at most) execute them locally and iterate on them with good velocity. These tests need to pass in order the component to be included in a compose.  After a bot makes a change to dist-git it automatically triggers the koji build.\nThe build in koji is validated that it works with the rest of the operating system packages in that branches compose. If it does it is then tagged into the compose.\nWhen validation fails, feedback goes back to the upstream project. At an absolute minimum the owner of the source git change. But it must be possible to send feedback to a minimal set of Git Forges (GitHub, GitLab, etc.).\nInstead of configuring the bots globally, the bot entry points (configuration) should live in the dist-git repositories (or source-git). The entry points may contain package specific code and variables that can affect the bot implementation for that repository.\nManual activities take place on source git. Humans may be involved in:\n Investigation of build, test, or packaging failures Material changes to spec files Material changes to test wrappers Writing documentation that describe the new changes Changes to packaging and delivery policy  We must get credentials for the bots to perform these activities. We must implement metering in the beginning to prevent bots going wild across the entire dist-git repository.\nAny change to the bots must self-validate by comparing recent bot behavior on recently changed dist-git repositories, and seeing if they have similar behavior.\nSpecifications and Interfaces Configuration in dist-git In order to automate dist-git and pull from source git, an extensible configuration file would be placed in dist-git (or source-git).\nPlacing this config in a branch in dist-git indicates that that dist-git branch should be auto-maintained. The config may be removed to turn off auto-maintenance. There is one config per auto-maintained branch, e.g. a config in f28 dist-git branch implies the branch is auto-maintained and points to specific source git branch.\nIt should at a minimum support:\n Which source git repository to pull from. Which branch in that source git repository to pull from. Optional: A container to do dist-git population with Defaults to the ‘default’ container (see below) Optional: An expression that describes how to parse tags in source git as versions This can be completely overridden by the container (see below) Eg: v4.9-rc8 -\u0026gt; 4.9 Optional: Which Koji buildroots to build in Defaults to the one decided by fedpkg Optional: GPG key ids considered valid for signing packages.  Source git best practices New upstream releases will result in new source-git branches. We can\u0026rsquo;t rebase existing branches since we would lose the provenance.\nThe diagram showcases how upstream releases (git tags) correspond to source git dist-git branches. New releases are automatically detected and proposed as a pull request. Once the packaging is completed, new corresponding branch is created and the new release should land in a continuously development (cont-dev) branch. Please bear in mind, that in order for a pull request to be merged, it needs to pass all the validation. Therefore in order for the 1.1.0 upstream release to land in the 1.1.0 source git branch, all the tests have to pass.\nIt’s up to a maintainer then to cherry-pick which changes should land in a selected downstream dist-git branch.\nPopulation of dist-git The actual population of dist-git and source git. Specification of the population process:\n The input, checked out source git will be placed in a known path. The container should process the input and place it to a well known path. The container image can live in any registry. Every maintainer will be able to create a container image to perform the population on their own, given it follows the specification.  After the population process is done, the bot collects the output, performs a commit, signs it and pushes to dist-git.\nThese two population mechanisms (=container images) will be available to maintainers:\n Default: produce an archive out of the source git content. No patch files. Upstream tarball: Take upstream release tarball and lay additional commits as patches on top.  Use case: Cockpit (where tarball very diverged from git)   Signing of source git This is a description of the initial proposal to perform signing of commits. Our expectation is that the design will evolve over time.\nThe HEAD commit on the tracked branch in source git, which represents the content to land in dist-git (see above), must be signed. When new commits are pushed to source git, a bot checks signatures used to sign those commits. The signature IDs which are approved to push to dist-git need to be specified in a configuration file placed in dist-git. If the signature ID is not in the configuration file, the commit is not synced and the bot notifies owners of the source git repository.\nWorkflow:\n A new signed commit is pushed to source git. A bot detects the commit, validates that it is signed using an approved signature.  If not, notifies maintainer to resolve the issue.  If the signature is valid, the bot prepares population of dist-git.  It uses the mechanism described in in previous section “Population of dist-git”. Before pushing to dist-git, the bot signs the commit with its own key. The bot also references the respective source git commit(s).  The commit is pushed to dist-git.  Summary: all commits in dist-git, which are curated by a bot, are signed with bot’s key. The commit message then references the commits in source git. All the mentioned commits need to be signed so it’s possible to figure out who authored and approved the work.\n"
},
{
	"uri": "https://packit.dev/docs/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " Packit uses a configuration file in the upstream repository. The config file is written in YAML language.\nYou should place the file in the root of your upstream repo. Packit accepts these names:\n .packit.yaml .packit.yml .packit.json packit.yaml packit.yml packit.json  Both Packit-as-a-Service and packit tool use this configuration file.\nTop level keys    Key name Type Description     specfile_path string relative path to a spec file within the upstream repository (mandatory)   upstream_project_name string name of the upstream repository (e.g. in PyPI); this is used in %prep section to generate an archive   create_pr bool when doing a new update in Fedora dist-git, should packit create a new pull request (when set to true) or push directly to dist-git (defaults to false) \u0026ndash; there is an issue in Pagure API version 5.5 and below that pull requests can\u0026rsquo;t be opened via API, for more info see packit-service/packit#328   synced_files list of strings or dicts a list of relative paths to files in the upstream repo which are meant to be copied to dist-git during an update   upstream_ref string git reference to last upstream git commit (for source-git repos)   downstream_package_name string name of the RPM package in Fedora   dist_git_namespace string namespace in dist-git URL (defaults to \u0026ldquo;rpms\u0026rdquo;)   dist_git_base_url string URL of dist-git server, defaults to https://src.fedoraproject.org/ (has to end with a slash)   create_tarball_command list of strings a command which generates upstream tarball in the root of the upstream directory (defaults to git archive -o \u0026quot;{package_name}-{version}.tar.gz\u0026quot; --prefix \u0026quot;{package_name}-{version}/\u0026quot; HEAD)   current_version_command list of strings a command which prints current upstream version (hint: git describe) (defaults to git describe --tags --match '*.*')   actions string custom actions/hooks overwriting the default behavior of packit (more in Actions)   jobs list of dicts a list of job definitions for packit service: see below for details   allowed_gpg_keys list of strings a list of gpg-key fingerprints; if specified, one of the configured keys have to sign the last commit when updating in downstream; add GitHub key (4AEE18F83AFDEB23) if you want to use this on code merged via GitHub web interface    Minimal sample config This is a sample config which is meant for packit itself.\n# we have the specfile in the root of our repository specfile_path: packit.spec # when doing an update in Fedora, we want to copy the spec file and the config file synced_files: - packit.spec - .packit.yaml # packit is named packitos on PyPI b/c packit name was already taken upstream_project_name: packitos # yes, packit is named packit in Fedora downstream_package_name: packit  More examples of synced_files synced_files: # copy a file from root of the upstream repo to dist-git - packit.spec # if you copy packit.yaml downstream, you can then take advantage of # `sync-from-downstream` command - .packit.yaml # src: a file in root of the upstream repository # dest: path within the downstream repository - src: packit.spec dest: redhat/packit.spec # also supports globbing: copy everything from fedora-packaging folder and # put it to the root of the dist-git repo - src: fedora-packaging/* dest: . # you can specify multiple source files as well: - src: - package.spec - some-file dest: .  Packit-as-a-Service As of July 2019, packit service doesn\u0026rsquo;t have any web interface, so the only way to change its behaviour is via the config file you just read about.\nWhen you open a pull request against your upstream repository, packit service picks up configuration file from your pull request, not from the branch against the PR is opened. This way, you can polish your .packit.yaml and see the results right away. (for more info, please see packit-service#48)\nPackit service jobs Once the service starts handling events of your repository, it needs to have a clear definition of what it should do.\nThe tasks the packit service should do are defined in section jobs. The section is a list of dicts:\njobs: - {key: value} - {}  Every job has two mandatory keys:\n job - name of the job (you can imagine this as a CLI command) trigger - what is the trigger for the job?  Every job only supports a specific set of triggers.\nJobs can also accept additional configuration in a key metadata which has dict as a value:\njobs: - job: some-job trigger: ran-out-of-beer metadata: key: value  Supported jobs copr_build\nCreate a SRPM and submit an RPM build to Fedora COPR build system.\nSupported triggers:\n pull_request \u0026ndash; check out content of the pull request release \u0026ndash; check out content of the tag associated with the release  Required metadata:\n targets - a list of mock chroots where to build (if you navigate to settings of your COPR project, you\u0026rsquo;ll be able able to see the list of available values, alternatively you can install package mock in Fedora and see the list via ls -1 /etc/mock/.  Optional metadata:\n timeout - (seconds) give up watching a build after timeout, defaults to 7200s, i.e. 2 hours owner - a namespace in COPR where the build should happen (defaults to packit) project - a name of the copr project (defaults to \u0026quot;{github_namespace}-{repository_name}-{pr_id}\u0026quot;)  If you want to build in your own COPR namespace, you need to grant packit permissions to build inside. The way COPR does this right now is that we, from the packit side, need to do a request for permissions. Please reach out to us via user-cont-team@redhat.com and we\u0026rsquo;d be glad to help you.\nExample\njobs: - job: copr_build trigger: pull_request metadata: targets: - fedora-rawhide-x86_64 - fedora-30-x86_64  sync_from_downstream\nPick up a change (mass rebuild, proven packager rebuild or a fix) from Fedora dist-git and send it to upstream repository.\nSupported triggers: commit.\nExample\njobs: - job: sync_from_downstream trigger: commit  propose_downstream\nLand a new upstream release in Fedora. This job only makes sure the changes happen in Fedora dist-git - no builds. The global key create_pr controls whether a pull request is created or changes are pushed directly.\nSupported triggers: release.\nOptional metadata:\n dist-git-branch - a branch in dist-git where packit should work (defaults to master)  Example\njobs: - job: propose_downstream trigger: release - job: propose_downstream trigger: release metadata: dist-git-branch: f30  This config would update Fedora Rawhide and Fedora 30 dist-git branches.\nUser configuration file When running packit as a tool locally, it is convenient to use a configuration file to provide data such as API tokens. Packit respects XDG_CONFIG_HOME environment variable. If not set, it looks inside ~/.config/ directory.\nThe acceptable names are the same as for the package config:\n .packit.yaml .packit.yml .packit.json packit.yaml packit.yml packit.json  Values    Key name Type Description     debug bool enable debug logs   dry_run bool Do not perform any remote changes (pull requests or comments)   fas_user string username in Fedora account system (to perform kinit if needed)   github_token string Github API token: this is needed when packit interacts with Github API: https://github.com/settings/tokens (getting full read \u0026amp; write repo scope should be enough)   pagure_user_token string Pagure token needed to access REST API, get it at: https://src.fedoraproject.org/settings#nav-api-tab   pagure_fork_token string a token so packit can create a pull request: https://src.fedoraproject.org/fork/YOU/rpms/PACKAGE/settings#apikeys-tab    You can also specify the tokens as environment variables: GITHUB_TOKEN, PAGURE_USER_TOKEN, PAGURE_FORK_TOKEN.\nMinimal sample config debug: true github_token: mnbvcxz123456 pagure_user_token: qwertyuiop098765  Server-side configuration These values are used to configure packit service. No need to bother with them, they serve as a documentation for us, packit service developers.\n   Key name Type Description     keytab_path string path to a Kerberos keytab file (requires fas_user to be set)   github_app_id string github app ID used for authentication   github_app_cert_path string path to a certificate associated with a github app   webhook_secret string when specified in a Github App settings, GitHub uses it to create a hash signature with each payload    "
},
{
	"uri": "https://packit.dev/docs/cli/create-bodhi-update/",
	"title": "create-bodhi-update",
	"tags": [],
	"description": "",
	"content": " Create a new bodhi update for the latest Fedora build of the upstream project.\nRequirements  Upstream git repository on Github. Packit config file placed in the upstream repository. Valid Fedora Kerberos ticket.  Tutorial  Place a config file for packit in the root of your upstream repository..\n Once the builds are done, you can run the create-update command. If you don\u0026rsquo;t specify the koji builds packit takes latest build.\n$ packit create-update --dist-git-branch f29 https://github.com/packit-service/packit.git Bodhi update FEDORA-2019-b72add0dcd: - https://bodhi.fedoraproject.org/updates/FEDORA-2019-b72add0dcd - stable_karma: 3 - unstable_karma: -3 - notes: \u0026quot;New upstream release 0.1.0\u0026quot;   Help Usage: packit create-update [OPTIONS] [PATH_OR_URL] Create a bodhi update for the selected upstream project PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Target branch in dist-git to release into. --koji-build TEXT Koji build (NVR) to add to the bodhi update (can be specified multiple times) --update-notes TEXT Bodhi update notes --update-type [security|bugfix|enhancement|newpackage] Type of the bodhi update -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/docs/how-to-source-git/",
	"title": "How to source-git?",
	"tags": [],
	"description": "",
	"content": " This is a practical introduction to source-git using a real example.\nIf you are interested in the theory behind source-git, please read the specification.\nLet\u0026rsquo;s create a source-git repo I choose systemd from Fedora 29 for this example.\nWhat do we need? 3 things:\n Systemd upstream repo. Fedora 29 dist-git repo of systemd. New local git repo.  Let\u0026rsquo;s set all of this up. We\u0026rsquo;ll start with an empty git repository:\n$ mkdir systemd-source-git $ cd systemd-source-git $ git init . Initialized empty Git repository in /home/tt/t/systemd-source-git/.git/  We\u0026rsquo;ll add fedora and upstream remotes, and then we\u0026rsquo;ll fetch them:\n$ git remote add upstream https://github.com/systemd/systemd.git $ git remote add fedora ssh://ttomecek@pkgs.fedoraproject.org/rpms/systemd.git $ git fetch -q upstream $ git fetch -q fedora  Systemd also has a dedicated repository with backports to the older releases. This is how systemd is packaged in Fedora.\n$ git remote add upstream-stable https://github.com/systemd/systemd-stable.git $ git fetch -q upstream-stable  We can start now Usually you would try to figure which upstream release is used so that you know what to choose for the base. But systemd in Fedora is not using the pristine upstream archives.\nWhen we open the Fedora 29 systemd spec file, we can see that upstream uses commit hash 8bca4621fc003a148c70248c55aa877dfe61fd3f for the upstream tarball from the systemd-stable repo. We\u0026rsquo;ll start a new git branch in our repo named 239-sg (sg as source-git):\n$ git checkout -B 239-sg 8bca4621fc003a148c70248c55aa877dfe61fd3f Switched to a new branch '239-sg'  Right now we have the upstream history which lead to the 239 release. Alternatively we could just unpack the upstream tarball and have the history in a single commit.\nIn this case, the upstream history is not marked in a any way, so let\u0026rsquo;s tag it:\n$ git tag upstream-239 HEAD  Packit will be able to distinguish between additional source-git content and upstream history.\nWe can start layering downstream content on top.\nLayering downstream content on top of upstream Let\u0026rsquo;s get files from the fedora/f29 branch.\n$ git checkout fedora/f29 -- . $ git status On branch 239-sg Changes to be committed: (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage) modified: .gitignore new file: 0001-Revert-journald-periodically-drop-cache-for-all-dead.patch new file: 0998-resolved-create-etc-resolv.conf-symlink-at-runtime.patch new file: 20-grubby.install new file: 20-yama-ptrace.conf new file: inittab new file: purge-nobody-user new file: sources new file: split-files.py new file: sysctl.conf.README new file: systemd-journal-gatewayd.xml new file: systemd-journal-remote.xml new file: systemd-udev-trigger-no-reload.conf new file: systemd-user new file: systemd.spec new file: triggers.systemd new file: yum-protect-systemd.conf  We have a bunch of new files from f29 branch in the root. We\u0026rsquo;ll move them now to the fedora/ directory:\n$ mkdir fedora $ mv $(git diff --name-only --cached) fedora/  and we should also clean our working tree:\n$ git reset HEAD . Unstaged changes after reset: M .gitignore $ git checkout .gitignore  \u0026hellip;and commit the fedora content now:\n$ git add fedora  We don\u0026rsquo;t want to commit those two patch files:\n$ git reset HEAD fedora/0001-Revert-journald-periodically-drop-cache-for-all-dead.patch fedora/0998-resolved-create-etc-resolv.conf-symlink-at-runtime.patch  We can now commit the files in fedora/ directory:\n$ git commit -m 'add fedora packaging' [239-sg 20548da6d9] add fedora packaging 15 files changed, 2901 insertions(+) create mode 100644 fedora/.gitignore create mode 100755 fedora/20-grubby.install create mode 100644 fedora/20-yama-ptrace.conf create mode 100644 fedora/inittab create mode 100755 fedora/purge-nobody-user create mode 100644 fedora/sources create mode 100644 fedora/split-files.py create mode 100644 fedora/sysctl.conf.README create mode 100644 fedora/systemd-journal-gatewayd.xml create mode 100644 fedora/systemd-journal-remote.xml create mode 100644 fedora/systemd-udev-trigger-no-reload.conf create mode 100644 fedora/systemd-user create mode 100644 fedora/systemd.spec create mode 100644 fedora/triggers.systemd create mode 100644 fedora/yum-protect-systemd.conf  Applying downstream patches We are getting to the core of source-git: we work with code in it, not with patches. Hence we need to apply the downstream patches:\n$ git am fedora/0001-Revert-journald-periodically-drop-cache-for-all-dead.patch Applying: Revert \u0026quot;journald: periodically drop cache for all dead PIDs\u0026quot; $ git am fedora/0998-resolved-create-etc-resolv.conf-symlink-at-runtime.patch Applying: resolved: create /etc/resolv.conf symlink at runtime $ git log --oneline| head -n 2 bcc2c8a292 resolved: create /etc/resolv.conf symlink at runtime 1d39b39df9 Revert \u0026quot;journald: periodically drop cache for all dead PIDs\u0026quot;  And that\u0026rsquo;s it, this is our source-git repo! You can check it out over here.\nOnce we finish source-git related code in packit, you\u0026rsquo;d be able then to work exclusively in source-git, getting results from tests and other testing systems directly on pull requests.\nWrap up As you can see, it is a lot of work to create the source-git repo. We are planning on automating it — creating a dedicated command in packit.\nWe also have a bunch of packit code related to source-git already done, but the overall experience is not done end-to-end.\n"
},
{
	"uri": "https://packit.dev/docs/cli/propose-update/",
	"title": "propose-update",
	"tags": [],
	"description": "",
	"content": " This is a detailed documentation for the update functionality of packit. The command creates a new pull request in Fedora using a selected or latest upstream release.\nRequirements  Upstream git repository on Github. Upstream release (read, git tag) where version in spec file is equivalent to the name of the git tag. Packit config file placed in the upstream repository. Spec file present in the upstream repository and is correct in a given release. Pagure API tokens for Fedora Dist-git. Github API token. Valid Fedora Kerberos ticket.  Tutorial  Place a file called .packit.yaml or packit.yaml in the root of your upstream repository.\n The configuration is described in this document. Please get inspired from an existing config in colin project.  Place a spec file into your upstream project (and make sure that specfile_path in the config has a correct value).\n This spec file will be then used to perform the update in Fedora. When you create a new upstream release, you should also update the spec file. Once your upstream release is out (and the spec file is really up to date), you can use packit to release it into Fedora.  Create a new upstream release. The spec file needs to be included in the ref for upstream release, because packit checks out the tag for the upstream release before copying files downstream.\n Pagure dist-git is configured in a way that it requires 2 API tokens in order to perform a pull request using the API (which packit is using). Please set these three environment variables using the appropriate tokens:\n export PAGURE_USER_TOKEN=\u0026lt;token\u0026gt; — this token is needed to access data in pagure. This is meant to be an API token of your user: https://src.fedoraproject.org/settings#nav-api-tab export PAGURE_FORK_TOKEN=\u0026lt;token\u0026gt; — packit needs this token to create a pull request: https://src.fedoraproject.org/fork/YOU/rpms/PACKAGE/settings#apikeys-tab If the fork does not exist, you have to create it in Pagure\u0026rsquo;s web interface. We are working with Fedora team to relax this requirement. export GITHUB_TOKEN=\u0026lt;token\u0026gt; — you can obtain the token over here: https://github.com/settings/tokens  Once you have performed the upstream release (and the new archive is up), run packit propose-update in a working directory of your upstream repository:\n$ git clone https://github.com/user-cont/colin.git $ cd colin $ packit propose-update using \u0026quot;master\u0026quot; dist-git branch syncing ./colin.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/c/colin/colin-0.3.0.tar.gz 100%[=============================\u0026gt;] 3.18M eta 00:00:00 downloaded archive: /tmp/tmpaanrpgjz/colin-0.3.0.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/colin/pull-request/4   Help Usage: packit propose-update [OPTIONS] [PATH_OR_URL] [VERSION] Release current upstream release into Fedora PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory VERSION argument is optional, the latest upstream version will be used by default Options: --dist-git-branch TEXT Target branch in dist-git to release into. --dist-git-path TEXT Path to dist-git repo to work in. Otherwise clone the repo in a temporary directory. --local-content Do not checkout release tag. Use the current state of the repo. --force-new-sources Upload the new sources also when the archive is already in the lookaside cache. -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/docs/cli/srpm/",
	"title": "srpm",
	"tags": [],
	"description": "",
	"content": " Create a SRPM of the present content in the upstream repository.\nBy default, packit uses git describe --tags --match '*.*' to create a unique version of the snapshot and git archive -o \u0026quot;{package_name}-{version}.tar.gz\u0026quot; --prefix \u0026quot;{package_name}-{version}/\u0026quot; HEAD to create a tarball with upstream sources.\nYou can override the archive and version commands in packit.yaml, e.g. this is what we use in ogr, a library which packit is using:\ncreate_tarball_command: [\u0026quot;python3\u0026quot;, \u0026quot;setup.py\u0026quot;, \u0026quot;sdist\u0026quot;, \u0026quot;--dist-dir\u0026quot;, \u0026quot;.\u0026quot;] current_version_command: [\u0026quot;python3\u0026quot;, \u0026quot;setup.py\u0026quot;, \u0026quot;--version\u0026quot;]  Requirements  Upstream project is using git. Packit config file placed in the upstream repository.  Tutorial  Place a config file for packit in the root of your upstream repository..\n Now we would generate a SRPM for ogr project:\n$ packit srpm Version in spec file is \u0026quot;0.0.3\u0026quot;. SRPM: /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm  We can now build the package:\n$ rpmbuild --rebuild /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm Installing /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.95VZ3c + umask 022 + cd /home/tt/rpmbuild/BUILD + cd /home/tt/rpmbuild/BUILD + rm -rf ogr-0.0.4.dev11+gc9956c9.d20190318 + /usr/bin/gzip -dc /home/tt/rpmbuild/SOURCES/ogr-0.0.4.dev11+gc9956c9.d20190318.tar.gz + /usr/bin/tar -xof - + STATUS=0 ... Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.aYyTMP ... Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.fotlPv ... + exit 0 Provides: python3-ogr = 0.0.4.dev11+gc9956c9.d20190318-1.fc29 python3.7dist(ogr) = 0.0.4.dev11+gc9956c9.d20190318 python3dist(ogr) = 0.0.4.dev11+gc9956c9.d20190318 Requires(rpmlib): rpmlib(CompressedFileNames) \u0026lt;= 3.0.4-1 rpmlib(FileDigests) \u0026lt;= 4.6.0-1 rpmlib(PartialHardlinkSets) \u0026lt;= 4.0.4-1 rpmlib(PayloadFilesHavePrefix) \u0026lt;= 4.0-1 Requires: python(abi) = 3.7 python3.7dist(gitpython) python3.7dist(libpagure) python3.7dist(pygithub) python3.7dist(python-gitlab) Checking for unpackaged file(s): /usr/lib/rpm/check-files /home/tt/rpmbuild/BUILDROOT/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.x86_64 Wrote: /home/tt/rpmbuild/RPMS/noarch/python3-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.noarch.rpm + exit 0   Help Usage: packit srpm [OPTIONS] [PATH_OR_URL] Create new SRPM (.src.rpm file) using content of the upstream repository. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --output FILE Write the SRPM to FILE instead of current dir. --remote TEXT Name of the remote to discover upstream project URL, If this is not specified, default to origin. --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). -h, --help Show this message and exit.  As you can see, it is possible to create SRPM for source-git repositories as well. Just add an --upstream-ref option to the packit command.\nIf you have a git tag 0.1.0 specifying the upstream code, just run packit srpm --upstream-ref 0.1.0 to create an SRPM file. It will create an archive from the given upstream reference (0.1.0) and following commits will be added as downstream patches.\nJust make sure, that you apply all the patches in the specfile. (Packit only adds the patches after the sources.) You can use a following setup:\n Define the macro on top of the specfile:\n%global num_patches %{lua: c=0; for i,p in ipairs(patches) do c=c+1; end; print(c);}  Apply the patches in the %prep part:\n%if %{num_patches} git init git config user.email \u0026quot;noreply@example.com\u0026quot; git config user.name \u0026quot;John Foo\u0026quot; git add . git commit -a -q -m \u0026quot;%{version} baseline.\u0026quot; # Apply all the patches. git am %{patches} %endif   "
},
{
	"uri": "https://packit.dev/docs/cli/sync-from-downstream/",
	"title": "sync-from-downstream",
	"tags": [],
	"description": "",
	"content": " This is a detailed documentation for the downstream sync functionality of packit. The command creates a new pull request in upstream repository using a selected branch (master by default) from Fedora dist-git repository.\nRequirements  Fedora dist-git repository. Packit config file placed in the upstream repository. Pagure API tokens for Fedora Dist-git. Github API token.  Tutorial  Pagure dist-git is configured in a way that it requires 2 API tokens in order to perform a pull request using the API (which packit is using). Please set these three environment variables using the appropriate tokens:\n export PAGURE_USER_TOKEN=\u0026lt;token\u0026gt; — this token is needed to access data in pagure. This is meant to be an API token of your user: https://src.fedoraproject.org/settings#nav-api-tab export PAGURE_FORK_TOKEN=\u0026lt;token\u0026gt; — packit needs this token to create a pull request: https://src.fedoraproject.org/fork/YOU/rpms/PACKAGE/settings#apikeys-tab If the fork does not exist, you have to create it in Pagure\u0026rsquo;s web interface. We are working with Fedora team to relax this requirement. export GITHUB_TOKEN=\u0026lt;token\u0026gt; — you can obtain the token over here: https://github.com/settings/tokens  Files which are synced are mentioned in .packit.yaml as synced_files value.\n Once you want to sync Fedora dist-git repo into the upstream repo, run packit sync-from-downstream in a working directory of your upstream repository:\n$ git clone https://github.com/user-cont/colin.git $ cd colin $ packit sync-from-downstream upstream active branch master Cloning repo: https://src.fedoraproject.org/rpms/colin.git -\u0026gt; /tmp/tmph9npe78e using master dist-git branch syncing /tmp/tmph9npe78e/colin.spec PR created: https://api.github.com/repos/phracek/colin/pulls/3  packit sync-from-downstream \u0026ndash;help Usage: packit sync-from-downstream [OPTIONS] [PATH_OR_URL] Copy synced files from Fedora dist-git into upstream by opening a pull request. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Source branch in dist-git for sync. --upstream-branch TEXT Target branch in upstream to sync to. --no-pr Pull request is not create. --fork / --no-fork Push to a fork. --remote-name TEXT Name of the remote where packit should push. if this is not specified, it pushes to a fork if the repo can be forked. -h, --help Show this message and exit.   "
},
{
	"uri": "https://packit.dev/faq/",
	"title": "FAQ",
	"tags": [],
	"description": "",
	"content": " Can I use the packit service as soon as I install it into my repository? Thanks for your interest in Packit Service! In order to start using the service you need to be whitelisted, which is an action to be done by us. Once we put you on the whitelist, we\u0026rsquo;ll get in touch with you. We are now on-boarding Fedora contributors (with a Fedora Account System account).\nCan I use packit service for any GitHub repository? Since packit service builds your PRs in Fedora COPR build service, by using Packit-as-a-service, your software needs to comply with COPR rules. If any of these points are violated, we\u0026rsquo;ll remove the builds and may put you on a blacklist so you won\u0026rsquo;t be able to use the service again.\nHow can I contact you? If you encounter a problem while using Packit-as-a-service, please open an upstream issue. In case of any other questions, feel free to contact us: user-cont-team@redhat.com.\nHow can I download RPM spec file if it is not part of upstream repository? If you do not want to have the RPM spec file in your upstream repository, you can download it in actions section.\nAdd actions section to your packit.yaml configuration file and download the spec file in a hook post_upstream_clone. Packit service has a limited set of commands available so please use wget or curl.\nThe configuration file with downloading the RPM spec file now looks like this:\nspecfile_path: packit.spec synced_files: - packit.spec - .packit.yaml upstream_project_name: packitos downstream_package_name: packit actions: post-upstream-clone: \u0026quot;wget https://src.fedoraproject.org/rpms/packit/raw/master/f/packit.spec\u0026quot;  "
},
{
	"uri": "https://packit.dev/docs/cli/copr-build/",
	"title": "copr-build",
	"tags": [],
	"description": "",
	"content": " Submit a Copr build of the present content in the upstream repository.\nRequirements  Upstream git repository on Github. Packit config file placed in the upstream repository. ~/.config/copr  Tutorial  Place a config file for packit in the root of your upstream repository.\n The command below would create a SRPM from the present content of a repo and perform copr-cli build with it. If you need to specify a project name/owner or chroots, see the options in help.\n$ cd my/ustream/project/ $ packit copr-build   Help Usage: packit copr-build [OPTIONS] [PATH_OR_URL] Build selected upstream project in COPR. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory. Options: --nowait Don't wait for build --owner TEXT Copr user, owner of the project. (defaults to username from ~/.config/copr) --project TEXT Project name to build in. Will be created if does not exist. (defaults to 'packit-cli-{repo_name}-{branch/commit}') --targets TEXT Comma separated list of chroots to build in. (defaults to 'fedora-rawhide-x86_64')  "
},
{
	"uri": "https://packit.dev/docs/cli/",
	"title": "Packit CLI Commands",
	"tags": [],
	"description": "",
	"content": " build create-bodhi-update propose-update srpm sync-from-downstream  "
},
{
	"uri": "https://packit.dev/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "Packit Packit provides tooling and automation to integrate upstream open source projects into Fedora operating system.\nUpstream repository https://github.com/packit-service/packit\nThe key principles of packit  Packit aims to make things easy and right. But if the default behavior is not the right for you, there is still a way around, but may not be that simple. For example you can use actions to replace default packit\u0026rsquo;s behavior with a script of yours.\n Reuse existing tools and services where it makes sense: don\u0026rsquo;t reinvent the wheel.\n You can consume packit in two forms:\n Packit tool can run on your laptop and you run commands you want. Packit service reacts to events and performs actions which you defined in your packit.yaml.  We don\u0026rsquo;t break backwards compatibility just like that.\n Packit has a deprecation policy:\n We can mark a behaviour as deprecated. Deprecated content can be removed or changed after at least 3 minor releases. Deprecated content is advertised in our changelog, printed in terminal or tracked in your issue tracker.  We care about artifacts which Fedora supports: at the moment it\u0026rsquo;s RPMs, modules and container images.\n Our initial focus is solely on RPMs.  Packit respects Fedora guidelines.\n We want latest content in Fedora Rawhide, but only if it works (the new content can be built and tests are passing).\n Any task done by the automation system must be able to be performed by a human when that is required. Packit service must be capable of recovering from such situation.\n Packit developers must be able to iterate on all parts packit (testing a change, merging a change, deploying to production) at a pace of at least every two weeks. To accomplish this, the release and validation processes are completely automated.\n Contributions to packit must be possible by any developer, maintainer, tester, or other engineer. Any Fedora developer or tester should be able to reproduce a bot locally on their machine, given appropriate credentials.\n  Why packit?  Our intent is to bring downstream and upstream communities closer: provide feedback from downstream to upstream. (e.g. \u0026ldquo;Hello \u0026lt;upstream project Y\u0026gt;, your newest release doesn\u0026rsquo;t work in Fedora Rawhide, it breaks \u0026lt;Z\u0026gt;, here is a link to logs.\u0026rdquo;)\n We want to only merge, build and compose components which integrate well with the rest of the operating system. The biggest impact of such behavior will be on Fedora Rawhide and when working on a new Fedora release.\n Automatically pull and validate new upstream releases. This can be a trivial thing to do, why should maintainers waste their times on work which can be automated.\n Developing in dist-git is cumbersome. Editing patch files and moving tarballs around is not fun. Why not working with the source code itself? With source-git, you\u0026rsquo;ll have upstream git history and the dist-git content combined in a single repository.\n Let\u0026rsquo;s use modern development techniques such as pull requests, code review, modern git forges, automation and continuous integration. We have computers to do all the mundane tasks. Why we, as humans, should do such work?\n We want dist-git to be \u0026ldquo;a database of content in a release\u0026rdquo; rather a place to do actual work. On the other hand, you\u0026rsquo;ll still be able to interact with dist-git the same way. We are not taking that away. Source-git is meant to be the modern, better alternative.\n  DevConf.cz \u0026ldquo;Auto-maintain your package\u0026rdquo; talk.\n"
},
{
	"uri": "https://packit.dev/posts/packit-042/",
	"title": "Packit 0.4.2",
	"tags": [],
	"description": "",
	"content": "Another relase after a month since 0.4.1, this time mostly with bug fixes.\nWe\u0026rsquo;ve been busy polishing our Github App recently, therefore we had no resources for new features.\nSee CHANGELOG for more details.\n"
},
{
	"uri": "https://packit.dev/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://packit.dev/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
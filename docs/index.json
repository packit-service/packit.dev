[
{
	"uri": "https://packit.dev/docs/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": " Actions Architecture Configuration for packit How to source-git? Packit CLI Packit Guide  "
},
{
	"uri": "https://packit.dev/docs/actions/",
	"title": "Actions",
	"tags": [],
	"description": "",
	"content": " You can probably find yourself in a situation where some part of the packit workflow needs to be tweaked for your package.\nPackit supports actions, a way to change default implementation for a command of your choice. Packit is able to execute more commands. Each action can accept a list of commands. By default, the commands are executed directly and not in a shell - if you need shell, just wrap your command like this: bash -c \u0026quot;my fancy $command | grep success\u0026quot;.\nAll the actions are also executed inside Packit-as-a-Service. The service creates a new sandbox environment where the command is ran.\nActions have a default behaviour which you can override, hooks don\u0026rsquo;t have any - hooks are a way for you to perform operations after packit does a specific event, e.g. clones an upstream repo.\nCurrently, these are the actions you can use:\npropose-update command     name working directory when run description     [hook] post-upstream-clone upstream git repo after cloning of the upstream repo (master) and before other operations    [hook] pre-sync upstream git repo after cloning and checkout to the correct (release) branch     prepare-files upstream git repo after cloning, checking out of both upstream and dist-git repos replace patching and archive generation    create-patches upstream git repo after sync of upstream files to the downstream replace patching    create-archive upstream git repo when the archive needs to be created replace the code for creating an archive    get-current-version upstream git repo when the current version needs to be found expect version as a stdout    Creating SRPM These applies to srpm command and building in COPR.\n    name working directory when run description     [hook] post-upstream-clone upstream git repo after cloning of the upstream repo (master) and before other operations     get-current-version upstream git repo when the current version needs to be found expect version as a stdout    create-archive upstream git repo when the archive needs to be created replace the code for creating an archive    create-patches upstream git repo after sync of upstream files to the downstream replace patching    fix-spec-file upstream git repo after creation of a tarball and before running rpmbuild command this action changes spec file to use the new tarball    create-archive - is expected to return the created archive name. If there are more steps, then one of them has to return the archive name.\nfix-spec-file — this action performs these 3 operations on a spec file:\n Replaces Source0 with a local path to the generated tarball Changes first %setup (or %autosetup) macro in %prep and adds -n so the generated tarball can be unpacked Changes %version  As an example how to use this, a package may define more Sources - in such a case, default implementation of fix-spec-file won\u0026rsquo;t be able to update %prep correctly. You can write a simple shell script and use sed to set the new Sources correctly, e.g. sed -i packaging/fedora/snapd.spec -e \u0026quot;s/https.*only-vendor.tar.xz/$correct_tarball_path/\u0026quot;\nEnvironment variables set by packit Additionally, packit sets a few env vars for specific actions\nfix-spec-file\nPACKIT_PROJECT_VERSION — current version of the project (coming from git describe) PACKIT_PROJECT_COMMIT — commit hash of the top commit PACKIT_PROJECT_ARCHIVE — expected name of the archive\ncreate-archive\nPACKIT_PROJECT_VERSION — current version of the project (coming from git describe) PACKIT_PROJECT_NAME_VERSION — current name and version of the project (coming from git describe)\nIn your package config they can be defined like this:\nspecfile_path: package.spec synced_files: - packit.yaml - package.spec upstream_package_name: package downstream_package_name: package dist_git_url: https://src.fedoraproject.org/rpms/package.git actions: prepare-files: \u0026quot;make prepare\u0026quot; create-archive: - \u0026quot;make archive\u0026quot; - \u0026quot;ls\u0026quot;  "
},
{
	"uri": "https://packit.dev/posts/packit-010/",
	"title": "Initial version (0.1.0) of packit is out!",
	"tags": [],
	"description": "",
	"content": "We would like to announce general availability of the initial version of packit, titled \u0026lsquo;0.1.0\u0026rsquo;.\nSince this is our first release, we would like to ask you to be patient if you encounter any issues. We work hard on packit\u0026rsquo;s usability. If you feel like that packit is doing something weird or if anything is unclear, don\u0026rsquo;t hesitate and reach out to us by creating a new Github issue.\nThe initial release contains two commands:\n packit propose-update — Opens a pull request in dist-git for the latest upstream release of a selected repository. packit watch-releases — Watches events for all the upstream releases and performs propose-update for those who use packit.  Installation $ dnf install --enablerepo=updates-testing packit  Or\n$ pip3 install --user packitos  Or (if you\u0026rsquo;re brave)\n$ pip3 install --user git+https://github.com/packit-service/packit  Requirements Present features have strict requirements on the upstream projects:\n You need to have a packit config file present in the upstream repo.\n You need to have spec file present in the upstream repo.\n  This workflow is suitable for people who are both upstream and downstream maintainers of the particular project. If you don\u0026rsquo;t fit into that bucket, then packit might not be ready for you, yet. Please wait till we land more source-git related functionality into packit.\npropose-update I\u0026rsquo;m going to demonstrate this functionality on ogr, our library for git forges, which powers packit.\nIt was recently approved for Fedora, so we can use packit to bring the initial version of ogr into Fedora Rawhide, 30 and 29.\nDo we have everything? Let\u0026rsquo;s see guide for the propose-update command on what we need:\n0. The upstream repository with a valid upstream release. $ git remote -v origin git@github.com:TomasTomecek/ogr.git (fetch) origin git@github.com:TomasTomecek/ogr.git (push) upstream https://github.com/packit-service/ogr.git (fetch) upstream https://github.com/packit-service/ogr.git (push)  Yup.\n$ git tag --list 0.0.1 0.0.2 0.0.3 $ git checkout 0.0.3 Note: checking out '0.0.3'.  And the tag name is matching the version in a spec file:\n$ grep Version python-ogr.spec Version: 0.0.3  1. Packit config file placed in the upstream repository. $ ll .packit.yaml -rw-rw-r--. 1 tt tt 177 Mar 1 17:44 .packit.yaml  Check.\n2. Spec file present in the upstream repository. $ ll python-ogr.spec -rw-rw-r--. 1 tt tt 1.3K Mar 1 17:43 python-ogr.spec  :+1:\n3. Pagure API tokens for Fedora Dist-git. $ env | grep TOKEN PAGURE_USER_TOKEN=will PAGURE_FORK_TOKEN=not GITHUB_TOKEN=share, sorry  4. Valid Fedora Kerberos ticket. $ kinit ttomecek@FEDORAPROJECT.ORG Password for ttomecek@FEDORAPROJECT.ORG: $ klist Ticket cache: KEYRING:persistent:1024:krb_ccache_g0t1Ty3Ah Default principal: ttomecek@FEDORAPROJECT.ORG Valid starting Expires Service principal 03/01/2019 18:12:25 03/02/2019 18:12:19 krbtgt/FEDORAPROJECT.ORG@FEDORAPROJECT.ORG renew until 03/08/2019 18:12:19  We\u0026rsquo;re all set!\nTime to shine We are still in the \u0026ldquo;ogr\u0026rdquo; upstream git repository.\n$ packit propose-update INFO: Running 'anitya' versioneer ERROR: Failed to determine latest upstream version! Check that the package exists on https://release-monitoring.org. using \u0026quot;master\u0026quot; dist-git branch syncing ./python-ogr.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.0.3.tar.gz 100%[=============================\u0026gt;] 17.95K eta 00:00:00 downloaded archive: /tmp/tmp2e65b0xt/ogr-0.0.3.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/1  Mind-blowing, isn\u0026rsquo;t it? Now we have latest python-ogr in Fedora Rawhide by running only a single command.\nI have also added ogr into release-monitoring as packit suggests.\nOnce we are okay with the changes, we have to merge the pull request. That\u0026rsquo;s our responsibility, as maintainers.\nBuilding in koji Time to build the package (packit doesn\u0026rsquo;t support building in koji, yet)\n$ fedpkg clone python-ogr Cloning into 'python-ogr'... remote: Counting objects: 8, done. remote: Compressing objects: 100% (5/5), done. remote: Total 8 (delta 0), reused 5 (delta 0) Receiving objects: 100% (8/8), done. $ cd python-ogr $ git log commit c298df5e540ba1d010366e102c1c75d4f5b0b0cc (HEAD -\u0026gt; master, origin/master, origin/HEAD) Author: Tomas Tomecek \u0026lt;ttomecek@redhat.com\u0026gt; Date: Fri Mar 1 18:15:00 2019 +0100 [packit] 0.0.3 upstream release more info Signed-off-by: Tomas Tomecek \u0026lt;ttomecek@redhat.com\u0026gt; commit 7d5ab1471ca0ee2a6c0254410b83beaa83b80f0b Author: Gwyn Ciesla \u0026lt;limb@fedoraproject.org\u0026gt; Date: Fri Mar 1 15:18:34 2019 +0000 Added the README  Yup, that\u0026rsquo;s our commit. more info was added there by accident, this is already fixed in packit.\n$ fedpkg build Building python-ogr-0.0.3-1.fc31 for rawhide Created task: 33125435 Task info: https://koji.fedoraproject.org/koji/taskinfo?taskID=33125435 Watching tasks (this may be safely interrupted)... 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): free 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): free -\u0026gt; open (buildvm-14.phx2.fedoraproject.org) 33125451 buildArch (python-ogr-0.0.3-1.fc31.src.rpm, noarch): open (buildvm-14.phx2.fedoraproject.org) 33125436 buildSRPMFromSCM (/rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): closed 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): open (buildvm-14.phx2.fedoraproject.org) -\u0026gt; closed 0 free 1 open 2 done 0 failed 33125464 tagBuild (noarch): closed 33125451 buildArch (python-ogr-0.0.3-1.fc31.src.rpm, noarch): open (buildvm-14.phx2.fedoraproject.org) -\u0026gt; closed 0 free 0 open 4 done 0 failed 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc) completed successfully  That was rough, can\u0026rsquo;t wait to do this with packit.\nLet\u0026rsquo;s do Fedora 30 now:\n$ packit propose-update --dist-git-branch f30 INFO: Running 'anitya' versioneer using \u0026quot;f30\u0026quot; dist-git branch syncing ./python-ogr.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.0.3.tar.gz 100%[=============================\u0026gt;] 17.95K eta 00:00:00 downloaded archive: /tmp/tmpl5xxq22x/ogr-0.0.3.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/3  And so on\u0026hellip;\nConclussion As you can see, packit is useful for us right away.\nWe\u0026rsquo;ll be delighted if you try it out and let us know what you think.\n"
},
{
	"uri": "https://packit.dev/docs/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://packit.dev/packit-as-a-service/",
	"title": "Packit-as-a-Service",
	"tags": [],
	"description": "",
	"content": " Packit-as-a-Service is a GitHub App that helps you continuously ensure that your project work in Fedora OS.\nEasy to use Using Packit Service is very straightforward: add one config file to your repository together with the RPM spec file and you\u0026rsquo;re good to go.\nPackit Service validates your pull requests by building your software in Fedora OS. Once the builds are done, Packit lets you know how to install the RPMs inside your environment so you can try the changes before merging them.\nOptionally, Packit Service can run tests for the built software (i.e. copr builds) in all current Fedora OS releases via Testing Farm.\nPackit is also available as a CLI tool, so you can always try things locally on your own. Note that testing is not currently supported with the CLI tool.\nIntegrating Packit-as-a-Service into your project or organization from GitHub Marketplace  Navigate to the \u0026ldquo;Packit-as-a-Service\u0026rdquo; GitHub application. Under \u0026ldquo;Pricing and setup\u0026rdquo;, click \u0026ldquo;Install it for free\u0026rdquo;. Click \u0026ldquo;Complete order and begin installation\u0026rdquo;. Install the \u0026ldquo;Packit-as-a-Service\u0026rdquo; to repositories of your choice.  Once installed, you will see the \u0026ldquo;Packit-as-a-Service\u0026rdquo; GitHub application in your project settings. In the left sidebar, click \u0026ldquo;Integration \u0026amp; services\u0026rdquo; and you will see the application displayed there.\nIn order to continue, please head to the main Packit guide.\nHow to check Packit Service works in your project? Currently, Packit Service is able only to build your changes and provide them as RPMs. Once you create a pull request, Packit Service builds the code from the pull request in COPR repository and reports back COPR build status to the pull request.\nAn example of Packit Service pull request:\nHow to re-trigger Packit Service actions in your pull request? Packit Service is able to schedule new builds based on a pull request comment:\n/packit copr-build  So whenever you run into a flake or feel like you want to retrigger, just type that comment into the PR and enjoy some fine, fresh builds.\nOnly project collaborators can re-trigger.\nHow to propose a new downstream update? Packit Service is able to propose updates of new upstream releases using this comment in an issue:\n/packit propose-update  If you want to propose the latest release into Fedora repositories, create an issue and add that comment into this issue and Packit service triggers and pushes it directly into Fedora dist-git repositories.\nIf all jobs (propose_downstream), defined in packit.yaml file, finished successfully, then the issue is automatically closed.\nOnly project collaborators can propose a new update.\nAdding tests It is also possible to run tests against the freshly built rpms. See the Testing Farm documentation for details.\n"
},
{
	"uri": "https://packit.dev/posts/packit-020/",
	"title": "Packit 0.2.0 is here!",
	"tags": [],
	"description": "",
	"content": "Our sprint nears an end which means we have released a new version of packit - 0.2.0! You can expect a new release after every sprint (i.e. every 2 weeks).\nThe 0.2.0 version has a bunch of new features and improvements: you can find a complete list in the changelog. We also have a detailed documentation for all the workflows packit covers.\nLet\u0026rsquo;s get through what\u0026rsquo;s new:\n We have decided to rename two keys in our config file so they are more descriptive. Old names still work but they are deprecated:  package_name → downstream_package_name upstream_name → upstream_project_name  You don\u0026rsquo;t need to touch dist-git at all when getting your new upstream release into Fedora, you can stay in your upstream repository and just fire off a bunch of packit calls:  packit propose-update to create a pull request in Fedora dist-git with the selected upstream release packit build to build the new upstream release once the pull request is merged and finally, packit create-update creates a new bodhi update (if you chose a stable Fedora release)  Packit now has a srpm command which creates an SRPM out of the local content of your upstream repository. You can now use packit to sync files from your dist-git repo back into upstream (mainly to keep spec files in sync). sync-from-downstream is the command. Command propose-update received numerous improvements:  You can pick upstream version to use. Packit will NOT check out the git ref with the upstream release if you specify --local-content It\u0026rsquo;s possible to force packit to execute fedpkg new-sources using --force-new-sources and bypass the caching mechanism.   Installation Please make sure you are installing 0.2.0:\n$ dnf install --enablerepo=updates-testing packit  Or\n$ pip3 install --user packitos  You can also install packit from master branch, if you are brave enough:\n$ pip3 install --user git+https://github.com/packit-service/packit  How are we using packit? I\u0026rsquo;d like to show you how we used packit to bring a new upstream release of ogr into Fedora, a library which packit is using.\nOnce we have performed an upstream release of ogr, we can propose an update in dist-git:\n$ git clone https://github.com/packit-service/ogr \u0026amp;\u0026amp; cd ogr/ $ packit propose-update INFO: Running 'anitya' versioneer Version in upstream registries is '0.0.3'. Version in spec file is '0.0.3'. Picking version of the latest release from the upstream registry over spec file. Checking out upstream version 0.0.3 Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpb9xlvdhj Syncing /home/tt/g/user-cont/ogr/python-ogr.spec Archive ogr-0.0.3.tar.gz found in lookaside cache (skipping upload). ERROR Cmd('git') failed due to: exit code(1) cmdline: git commit -s -m [packit] 0.0.3 upstream release -m Upstream tag: 0.0.3 Upstream commit: 059d21080a7849acff4626b6e0ec61830d537ac4 stdout: 'On branch 0.0.3-master-update nothing to commit, working tree clean'  Whoops, it seems that I have messed up, I forgot to bump the spec file in the upstream repo when doing the release. I will bump it locally and utilize --local-content argument:\n$ rpmdev-bumpspec -n 0.1.0 -c 'New upstream release: 0.1.0' *.spec $ packit propose-update --local-content INFO: Running 'anitya' versioneer Version in upstream registries is '0.0.3'. Version in spec file is '0.1.0'. Picking version of the latest release from the upstream registry over spec file. Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpd9j4se27 Syncing /home/tt/g/user-cont/ogr/python-ogr.spec Archive ogr-0.1.0.tar.gz found in lookaside cache (skipping upload). INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.1.0.tar.gz 100%[=============================\u0026gt;] 20.25K eta 00:00:00 Downloaded archive: '/tmp/tmpd9j4se27/ogr-0.1.0.tar.gz' About to upload to lookaside cache won't be doing kinit, no credentials provided PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/6  Once the scratch build is done and tests passed we merged and built it:\n$ packit build Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmprp3cmdjy Building python-ogr-0.1.0-1.fc31 for rawhide Created task: 33616980 Task info: https://koji.fedoraproject.org/koji/taskinfo?taskID=33616980  We have done the same for F30 and F29.\nThe previous commands were ran in the directory of the upstream repository. Packit also accepts path to your upstream clone, or even URL. So let\u0026rsquo;s create a bodhi update for python-ogr by specifying the upstream repo URL:\n$ cd $HOME $ packit create-update --dist-git-branch f29 https://github.com/packit-service/ogr Cloning repo: https://github.com/packit-service/ogr -\u0026gt; /tmp/tmpdkdadmn_ Koji builds for package python-ogr and koji tag f29-updates-candidate: - python-ogr-0.1.0-1.fc29 Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpn1809ec9 Bodhi update FEDORA-2019-78948e62d2: - https://bodhi.fedoraproject.org/updates/FEDORA-2019-78948e62d2 - stable_karma: 3 - unstable_karma: -3 - notes: New upstream release: 0.1.0  And that\u0026rsquo;s it, no need to access dist-git any more.\nPlease give packit a try and let us know what you think.\n"
},
{
	"uri": "https://packit.dev/posts/",
	"title": "Blog Posts",
	"tags": [],
	"description": "",
	"content": " Packit 0.1.0 Packit 0.2.0 Packit 0.3.0 Packit 0.4.0 \u0026amp; 0.4.1 November 2019 December 2019 January 2020 February 2020  "
},
{
	"uri": "https://packit.dev/posts/packit-030/",
	"title": "Packit 0.3.0",
	"tags": [],
	"description": "",
	"content": "In the previous post we promised to provide a new release every 2 weeks and we are already breaking this promise as it\u0026rsquo;s been 3 weeks since then. We decided to wait with the release to merge several pull requests related to source-git support.\nNow the good news. You can find a complete list of new features and improvements of version 0.3.0 in the changelog.\nFeatures  You can now specify your own hooks or actions to replace default packit behaviour. (More information can be found in the documentation). Packit supports pagure.io-based upstream projects. Commands propose-update and sync-from-downstream supports copying directories. A new command status! It displays useful upstream/downstream info. Packit now supports Source-git. The functionality is not available, yet - we will add a CLI interface for it in the next release. You can now have a config file for packit in your home directory(~/.config/packit.yaml). Packit installed from an RPM now has manpages.  packit status example $ packit status Cloning repo: https://src.fedoraproject.org/rpms/packit.git -\u0026gt; /tmp/tmp84we_6n8 Downstream PRs: No open PRs. f29: 0.2.0 f30: 0.2.0 master: 0.2.0 "
},
{
	"uri": "https://packit.dev/docs/cli/build/",
	"title": "build",
	"tags": [],
	"description": "",
	"content": " Submit a koji build for the selected branch in Fedora dist-git.\nRequirements  Upstream git repository on Github. Packit config file placed in the upstream repository. Valid Fedora Kerberos ticket.  Tutorial  Place a config file for packit in the root of your upstream repository.\n The command below would perform fedpkg build in the Fedora dist-git master branch.\n$ cd my/ustream/project/ $ packit build   Help Usage: packit build [OPTIONS] [PATH_OR_URL] Build selected upstream project in Fedora. Packit goes to dist-git and performs `fedpkg build` for the selected branch. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Target branch in dist-git to release into. --dist-git-path TEXT Path to dist-git repo to work in. Otherwise clone the repo in a temporary directory. --scratch Submit a scratch koji build -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/docs/guide/",
	"title": "Packit Guide",
	"tags": [],
	"description": "",
	"content": " Agenda Being fully on-board of the packit train may take some time and effort. This is why we decided to split the on-boarding process into multiple checkpoints:\n Have packit tooling installed locally. RPM builds pass on your laptop. You are approved to use packit-service. The project has successful builds inside the service. Packit service handles Fedora Rawhide updates for you.  The guide We welcome all the suggestions to this guide, feel free to open a new issue here.\nHave packit tooling installed locally. In order to start using packit, it\u0026rsquo;s a best practice to install the tooling locally. All the logic is baked inside packit command - so once packit srpm (the command to create a source RPM locally from the current snapshot of the project) starts passing for you, it\u0026rsquo;s very likely it will work inside the packit service as well.\nThis is how you can install packit if you are on Fedora Linux:\n$ dnf install --enablerepo=updates-testing packit  We publish packit to PyPI and it\u0026rsquo;s available as packitos project — packit at PyPI is something different\n$ pip3 install --user packitos  You can also help us test the latest development snapshot by installing packit directly from the master branch:\n$ pip3 install --user git+https://github.com/packit-service/packit  RPM builds pass on your laptop. Once you install packit locally, it\u0026rsquo;s time to fill .packit.yaml — the configuration file packit is using.\nThe documentation file has a document on its own: configuration.\nPackit supports actions and hooks: you can define commands on your own which would replace packit\u0026rsquo;s implementation (e.g. get version, or create a tarball) or run specific commands after the upstream repo is cloned. Please read more about actions here: actions.\nPackit needs an RPM spec file to build your package. The spec file does not need to be included in the upstream repo and can be generated on the fly or downloaded (e.g. from Fedora dist-git). Please check out our FAQ to read about some other common questions.\nYou can also read more about the SRPM process in the document dedicated to the srpm command.\nIs your packit srpm finally passing? If not, feel free to reach out to us. If yes, let\u0026rsquo;s proceed to the next level.\nRunning from the dist-git repository When you are not allowed or do not want to run packit command from the upstream git repository, you can run commands from the cloned dist-git repository in the same way as you do from upstream. Make sure, that you specify the upstream_project_url in your configuration.\nYou are approved to use packit-service. In order to start using packit service, the killer GitHub app, you need to install it in your GitHub projects. Then we need to approve you (usually takes only a few hours).\nThis process is described in detail over here.\nThe project has successful builds inside the service. If a SRPM can be created locally, all should be good in the service as well. That\u0026rsquo;s the theory. In practice, your laptop and packit service sandbox environment are vastly different. One thing which can happen easily is that a command is not available in the sandbox. Also, all the commands are ran using an unprivileged user - you can\u0026rsquo;t install anything or perform any privileged operation. In any case, feel free to reach out to us if you are having troubles and we\u0026rsquo;d be glad to help.\nIn order to get RPM builds for every change in your project, you need add a section jobs inside your .packit.yaml and set up a job to do RPM builds for every change in a PR:\njobs: - job: copr_build trigger: pull_request metadata: targets: - fedora-all  fedora-all stands for all currently available Fedora releases.\nJobs are nicely described over here.\nIf you are looking for an inspiration for your .packit.yaml, check packit\u0026rsquo;s config file since we try to use all the latest features.\nPackit service handles Fedora Rawhide updates for you. So you already have jobs section in your config. Let\u0026rsquo;s extend it with another job to push new upstream releases to Fedora rawhide.\njobs: - job: propose_downstream trigger: release metadata: dist-git-branch: master  Pretty clear I\u0026rsquo;d say: when a new upstream release happens, propose it to dist-git master branch: Fedora Rawhide. Packit enables you to decide whether you want to do a direct push or create a pull request. If you want direct pushes, you need to set a global config option create_pr to false:\ncreate_pr: false jobs: - job: propose_downstream trigger: release metadata: dist-git-branch: master  Packit user in Fedora is not a proven packager, so you need to grant packit user the ability to push.\nCreating pull requests is easy. create_pr defaults to true so the config starting this section is good enough.\n"
},
{
	"uri": "https://packit.dev/posts/packit-041/",
	"title": "Packit 0.4.0 &amp; 0.4.1",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s been over a month since we released packit \u0026ldquo;0.3.0\u0026rdquo;. Here comes packit 0.4.0 (and patch release 0.4.1) and as always they bring a lot of new features and improvements.\nYou can find a complete list in the changelog.\nPackit as a service  We have Packit as a service running in OpenShift and also a GitHub App, which uses it. Unfortunately it\u0026rsquo;s still not in the Marketplace, so we have been the only one using it so far. The service/app submits builds in copr and once they\u0026rsquo;re done it adds a GitHub status and comment with instructions how to install the builds. The service is now configurable via jobs defined in configuration file. Packit is now able to check GPG signatures of the upstream commits against configured fingerprints.  CLI  srpm command now works also with Source-git. status command now access remote APIs asynchronously in parallel, which should speed up the execution. CLI has new --dry-run option to not perform any remote changes (pull requests or comments). Fedmsg parsing has been unified into a single listen-to-fedmsg command. "
},
{
	"uri": "https://packit.dev/source-git/",
	"title": "Source-git",
	"tags": [],
	"description": "",
	"content": "Source git is the place where the manual work is done This document serves as a detailed description of source-git. Please bear in mind that some things are a subject to change — the overall design is pretty solid, but details may be tinkered over time.\nAuthors: Stef Walter, Tomas Tomecek\nTL;DR Content of source-git repository is equivalent to dist-git, but uses upstream format: source files instead of tarballs, git commits instead of patches.\nYou can host this repository, or the specific git branch, anywhere you want. If you open a pull request, you will receive feedback on the changes:\n Does the package build with the changes? Do all the package tests pass? How about tests of the dependant packages? Are the changes good to be included in Fedora?  The goal of packit is to provide automation and tooling to interact with source-git repositories so you don\u0026rsquo;t have to touch dist-git ever again. Our plan is to center development experience around upstream repositories and source-git.\nUpstream repositories and source-git repositories are pretty much the same thing. Creating source-git only makes sense when the upstream does not accept downstream spec file or adding spec file to such a project doesn\u0026rsquo;t make sense.\nFull description Source git becomes the place for creative and interesting work, including aspects of packaging requiring human effort. We allow dist-git to become an auto-maintained location, used for tracking the current state of Fedora, rather than the place where any actual development happens.\nBecause source git is the location for creative work, we can use modern tooling, GitHub, GitLab, Pagure, pull requests, code review, continuous integration and other modern development workflows.\nIn many cases source git can be the upstream project git itself (mostly with projects where downstream maintainer is also the upstream maintainer). In other cases source git can be a fork of upstream git (such as with the Linux kernel).\nWe take cues from projects that already do this. We use the distributed nature of git repositories to overcome obstacles where certain parts of a package (patches, spec, tests) can not (due to embargoes/secrets) or will not (due the upstream project) be included in the upstream source git.\nBots are perfect candidates to perform the mundane tasks of auto-maintaining dist-git. Whenever a bot gets stuck, it can always ask maintainer for help (or the maintainer can perform the action for the bot).\nPremises One of the fundamentally useless manual activities when a maintaining a package in Fedora is moving code from one git repository format to another. a) git is distributed b) dist-git content is mostly boilerplate or regurgitated data.\nLinux distributions gain an advantage from having patches incorporated upstream and not carrying them downstream.\nHuman effort should not be focused on repetitive automatible tasks related to churn and moving code around.\nDist-git is used as a store of state for build tools (like koji). Reinventing dist-git itself fundamentally, means reinventing a lot of tooling.\nPrinciples Dist-git tracks the inputs for and source state of a package build in Fedora. It is not a place for development. It is the place where integration happens.\nA Dist-git branch may diverge from the stable state of a Fedora release. The stable state is represented by which builds were tagged into the stable compose, not by what is in dist-git.\nAim to do Fedora development of a package in source git. Either directly in upstream or in downstream git forks and branches of the upstream (see the kernel for longest running example of this).\nAny repetitive task, whether repetitive for a single package, or repetitive across packages should be owned by bots auto-maintaining dist-git. Any creative non-automatable human task should be done in source git.\nWe are starting this project open source from the beginning.\nAcceptance Criteria In the ideal path, dist-git should be completely automatically “maintained” (already done to varying extents in the kernel, systemd, cockpit, ostree, conu, colin and other packages).\nIt must be trivially possible to opt in and out of auto-maintenance for a given dist-git branch.\nIt should continue to be possible for a human to fix up a dist-git branch, in cases where a task was done incorrectly by a bot. Bots may overwrite such fixups.\nEach auto-maintained dist-git branch tracks a branch in a source git repository. The source git branch should share a common git history with the upstream project branches if maintainer desires such functionality.\nEach time the HEAD of the git source branch changes, a process is started to update dist-git to reflect those changes. This process may also be triggered manually via a tool. If the dist-git is not in an expected state (last commit is not from the bot), the bot should report such divergence.\nOnly the most recent signed commit is a candidate for pulling into dist-git.\nSource code and patches are pulled from source git branch:\n The source code is the git source branch itself. The latest git tag of the git source branch is treated as the release. It must be possible to ignore certain tag patterns. Any commits after that tag in the git source branch are treated as additional patches to be distributed. In order to turn it into an SRPM and include it into dist-git it may be automatically turned into a tarball via an archive command on its latest tag. It must also be possible to use released tarballs from a project if available and necessary for a given dist-git repository, and layer patch files on top in dist-git.  Spec files are pulled from source:\n In the ideal case a spec file is maintained upstream in the same git repository as the source code. This is similar to how many projects have a Dockerfile. When upstream does not accept a spec file, it should be placed as an additional commit in the source git branch, and carried as if it were a patch. To allow trivial revert, review and merge workflows, the release number of the spec file is automatically generated (eg: SuSE and OBS). The release number should be present in the SRPM file name and contents. %changelog in an SRPM is automatically generated from the commits in source git repository. Various techniques may be used to collapse history. Project specific tooling in the source git repo can be used to generate the spec file (eg: as seen today in the kernel). We must provide reference implementation of such script. A spec file can be auto-generated for new packages, and reviewed by a human, who can do FIXUPs.  See: https://github.com/clearlinux/autospec   Tests are pulled from source:\n Components of the operating system have integration and acceptance tests. In the ideal case these are maintained upstream in the given project. They are treated similar to source code. When an upstream does not accept a test, it should be placed as an additional commit in the branch of the git source repository, and carried as if it was a patch. Tests should be wrapped in such a way that anyone can easily (2 commands at most) execute them locally and iterate on them with good velocity. These tests need to pass in order the component to be included in a compose.  After a bot makes a change to dist-git it automatically triggers the koji build.\nThe build in koji is validated that it works with the rest of the operating system packages in that branches compose. If it does it is then tagged into the compose.\nWhen validation fails, feedback goes back to the upstream project. At an absolute minimum the owner of the source git change. But it must be possible to send feedback to a minimal set of Git Forges (GitHub, GitLab, etc.).\nInstead of configuring the bots globally, the bot entry points (configuration) should live in the dist-git repositories (or source-git). The entry points may contain package specific code and variables that can affect the bot implementation for that repository.\nManual activities take place on source git. Humans may be involved in:\n Investigation of build, test, or packaging failures Material changes to spec files Material changes to test wrappers Writing documentation that describe the new changes Changes to packaging and delivery policy  We must get credentials for the bots to perform these activities. We must implement metering in the beginning to prevent bots going wild across the entire dist-git repository.\nAny change to the bots must self-validate by comparing recent bot behavior on recently changed dist-git repositories, and seeing if they have similar behavior.\nSpecifications and Interfaces Configuration in dist-git In order to automate dist-git and pull from source git, an extensible configuration file would be placed in dist-git (or source-git).\nPlacing this config in a branch in dist-git indicates that that dist-git branch should be auto-maintained. The config may be removed to turn off auto-maintenance. There is one config per auto-maintained branch, e.g. a config in f28 dist-git branch implies the branch is auto-maintained and points to specific source git branch.\nIt should at a minimum support:\n Which source git repository to pull from. Which branch in that source git repository to pull from. Optional: A container to do dist-git population with Defaults to the ‘default’ container (see below) Optional: An expression that describes how to parse tags in source git as versions This can be completely overridden by the container (see below) Eg: v4.9-rc8 -\u0026gt; 4.9 Optional: Which Koji buildroots to build in Defaults to the one decided by fedpkg Optional: GPG key ids considered valid for signing packages.  Source git best practices New upstream releases will result in new source-git branches. We can\u0026rsquo;t rebase existing branches since we would lose the provenance.\nThe diagram showcases how upstream releases (git tags) correspond to source git dist-git branches. New releases are automatically detected and proposed as a pull request. Once the packaging is completed, new corresponding branch is created and the new release should land in a continuously development (cont-dev) branch. Please bear in mind, that in order for a pull request to be merged, it needs to pass all the validation. Therefore in order for the 1.1.0 upstream release to land in the 1.1.0 source git branch, all the tests have to pass.\nIt’s up to a maintainer then to cherry-pick which changes should land in a selected downstream dist-git branch.\nPopulation of dist-git The actual population of dist-git and source git. Specification of the population process:\n The input, checked out source git will be placed in a known path. The container should process the input and place it to a well known path. The container image can live in any registry. Every maintainer will be able to create a container image to perform the population on their own, given it follows the specification.  After the population process is done, the bot collects the output, performs a commit, signs it and pushes to dist-git.\nThese two population mechanisms (=container images) will be available to maintainers:\n Default: produce an archive out of the source git content. No patch files. Upstream tarball: Take upstream release tarball and lay additional commits as patches on top.  Use case: Cockpit (where tarball very diverged from git)   Signing of source git This is a description of the initial proposal to perform signing of commits. Our expectation is that the design will evolve over time.\nThe HEAD commit on the tracked branch in source git, which represents the content to land in dist-git (see above), must be signed. When new commits are pushed to source git, a bot checks signatures used to sign those commits. The signature IDs which are approved to push to dist-git need to be specified in a configuration file placed in dist-git. If the signature ID is not in the configuration file, the commit is not synced and the bot notifies owners of the source git repository.\nWorkflow:\n A new signed commit is pushed to source git. A bot detects the commit, validates that it is signed using an approved signature.  If not, notifies maintainer to resolve the issue.  If the signature is valid, the bot prepares population of dist-git.  It uses the mechanism described in in previous section “Population of dist-git”. Before pushing to dist-git, the bot signs the commit with its own key. The bot also references the respective source git commit(s).  The commit is pushed to dist-git.  Summary: all commits in dist-git, which are curated by a bot, are signed with bot’s key. The commit message then references the commits in source git. All the mentioned commits need to be signed so it’s possible to figure out who authored and approved the work.\n"
},
{
	"uri": "https://packit.dev/docs/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " Packit uses a configuration file in the upstream repository. The config file is written in YAML language.\nYou should place the file in the root of your upstream repo. Packit accepts these names:\n .packit.yaml .packit.yml .packit.json packit.yaml packit.yml packit.json  Both Packit-as-a-Service and packit tool use this configuration file.\nTop level keys specfile_path (string) Relative path to a spec file within the upstream repository (if not specified, Packit will recursively search the tree and use the first spec file found).\nupstream_project_name (string) Deprecated since packit-0.7.0, use upstream_package_name instead.\nupstream_package_name (string) Name of the upstream repository (e.g. in PyPI), defaults to the name of the Github repository; this is used in %prep section to generate an archive.\nupstream_project_url (string) URL of the upstream project (e.g. https://github.com/packit-service/packit).\ncreate_pr (bool) When doing a new update in Fedora dist-git, should packit create a new pull request (defaults to true) or push directly to dist-git (if set to false).\nsynced_files (list of strings or dicts) A list of relative paths to files in the upstream repo which are meant to be copied to dist-git during an update (spec file path and config file path are set every time by default).\nupstream_ref (string) Git reference to last upstream git commit (for source-git repos).\ndownstream_package_name (string) Name of the RPM package in Fedora, defaults to the name of the Github repository.\ndist_git_namespace (string) Namespace in dist-git URL (defaults to \u0026ldquo;rpms\u0026rdquo;).\ndist_git_base_url (string) URL of dist-git server, defaults to https://src.fedoraproject.org/ (has to end with a slash).\ncreate_tarball_command (list of strings) A command which generates upstream tarball in the root of the upstream directory (defaults to git archive -o \u0026quot;{package_name}-{version}.tar.gz\u0026quot; --prefix \u0026quot;{package_name}-{version}/\u0026quot; HEAD).\ncurrent_version_command (list of strings) A command which prints current upstream version (hint: git describe) (defaults to git describe --tags --match '*.*').\nactions (string) Custom actions/hooks overwriting the default behavior of packit (more in Actions).\njobs (list of dicts) A list of job definitions for packit service: see below for details.\nallowed_gpg_keys (list of string) A list of gpg-key fingerprints; if specified, one of the configured keys have to sign the last commit when updating in downstream; add GitHub key (5DE3E0509C47EA3CF04A42D34AEE18F83AFDEB23) if you want to use this on code merged via GitHub web interface.\nspec_source_id (int or string) Numeric ID of Source inside spec file which packit should change when setting path to the newly generated tarball, can be also full name of the macro. Defaults to Source0 or Source, whichever is found first in the spec file.\nupstream_tag_template (string) Packit by default expects git tags to match versions (e.g. when doing the propose-update command) - if you are using a different tagging scheme, let\u0026rsquo;s say v1.2.3 you can then set this parameter to v{version} and packit will fill in the version argument.\npatch_generation_ignore_paths (list of strings) In a source-git repo, when packit is generating patches, it excludes changes to the spec file and packit.yaml by default: with this option you can precisely specify paths to exclude.\nMinimal sample config This is a sample config which is meant for packit itself.\n# packit is named packitos on PyPI b/c packit name was already taken upstream_package_name: packitos  More examples of synced_files synced_files: # copy a file from root of the upstream repo to dist-git - packit.spec # if you copy packit.yaml downstream, you can then take advantage of # `sync-from-downstream` command - .packit.yaml # src: a file in root of the upstream repository # dest: path within the downstream repository - src: packit.spec dest: redhat/packit.spec # also supports globbing: copy everything from fedora-packaging folder and # put it to the root of the dist-git repo - src: fedora-packaging/* dest: . # you can specify multiple source files as well: - src: - package.spec - some-file dest: .  Packit-as-a-Service As of July 2019, packit service doesn\u0026rsquo;t have any web interface, so the only way to change its behaviour is via the config file you just read about.\nWhen you open a pull request against your upstream repository, packit service picks up configuration file from your pull request, not from the branch against the PR is opened. This way, you can polish your .packit.yaml and see the results right away. (for more info, please see packit-service#48)\nPackit service jobs Once the service starts handling events of your repository, it needs to have a clear definition of what it should do.\nThe tasks the packit service should do are defined in section jobs. The section is a list of dicts:\njobs: - {key: value} - {}  If there is no jobs section in the configuration file, jobs default to:\njobs: - job: copr_build trigger: pull_request metadata: targets: fedora-stable - job: propose_downstream trigger: release metadata: dist-git-branch: fedora-all  If you do not want to use the jobs then the jobs section in the configuration file should be empty:\njobs: []  Every job has two mandatory keys:\n job - name of the job (you can imagine this as a CLI command) trigger - what is the trigger for the job?  Every job only supports a specific set of triggers.\nJobs can also accept additional configuration in a key metadata which has dict as a value:\njobs: - job: some-job trigger: ran-out-of-beer metadata: key: value  Supported jobs copr_build\nCreate a SRPM and submit an RPM build to Fedora COPR build system.\nSupported triggers:\n pull_request \u0026ndash; check out content of the pull request release \u0026ndash; check out content of the tag associated with the release  Required metadata:\n targets - a list of mock chroots where to build (if you navigate to settings of your COPR project, you\u0026rsquo;ll be able able to see the list of available values, alternatively you can install package copr-cli in Fedora and see the list via copr-cli list-chroots. You can use fedora-development, fedora-stable and fedora-all aliases as a target. By default, the x86_64 architecture will be used, but you can use e.g. fedora-stable-aarch64 if you need.  Optional metadata:\n timeout - (seconds) give up watching a build after timeout, defaults to 7200s, i.e. 2 hours owner - a namespace in COPR where the build should happen (defaults to packit) project - a name of the copr project (defaults to \u0026quot;{github_namespace}-{repository_name}-{pr_id}\u0026quot;)  If you want to build in your own COPR namespace, you need to grant packit permissions to build inside. The way COPR does this right now is that we, from the packit side, need to do a request for permissions. Please reach out to us via user-cont-team@redhat.com and we\u0026rsquo;d be glad to help you.\nExample\njobs: - job: copr_build trigger: pull_request metadata: targets: - fedora-stable - centos-stream-x86_64  With this configuration, you\u0026rsquo;ll get builds in all stable fedora releases (excluding rawhide) and the CentOS stream.\nsync_from_downstream\nPick up a change (mass rebuild, proven packager rebuild or a fix) from Fedora dist-git and send it to upstream repository.\nSupported triggers: commit.\nExample\njobs: - job: sync_from_downstream trigger: commit  propose_downstream\nLand a new upstream release in Fedora. This job only makes sure the changes happen in Fedora dist-git - no builds. The global key create_pr controls whether a pull request is created or changes are pushed directly.\nSupported triggers: release.\nOptional metadata:\n dist-git-branch - a branch in dist-git where packit should work (defaults to master). You can also use fedora-development, fedora-stable and fedora-all aliases to not need to change the config file when the new system version is released.  Example\njobs: - job: propose_downstream trigger: release - job: propose_downstream trigger: release metadata: dist-git-branch: f30  This config would update Fedora Rawhide and Fedora 30 dist-git branches.\nUser configuration file When running packit as a tool locally, it is convenient to use a configuration file to provide data such as API tokens. Packit respects XDG_CONFIG_HOME environment variable. If not set, it looks inside ~/.config/ directory.\nThe acceptable names are the same as for the package config:\n .packit.yaml .packit.yml .packit.json packit.yaml packit.yml packit.json  Values    Key name Type Description     debug bool enable debug logs   fas_user string username in Fedora account system (to perform kinit if needed)   authentication dict tokens for services (GitHub, Pagure)    The authentication is a dictionary where: * key is a hostname, url or name that can be mapped to a service-type, for example github.com or pagure * value is a dictionary with keys: token and instance_url (optional)\ne.g.:\nauthentication: github.com: token: mnbvcxz123456 pagure: token: qwertyuiop098765 instance_url: https://src.fedoraproject.org  The GitHub token is needed when packit interacts with Github API, get it at https://github.com/settings/tokens (getting full read \u0026amp; write repo scope should be enough). The Pagure token needed to access REST API, get it at https://src.fedoraproject.org/settings#nav-api-tab\nSpecifying tokens as direct keys github_token and pagure_user_token has been deprecated and will be removed in future versions.\nSince API tokens are a very sensitive information, please do NOT ever store them in a public (such as a GitHub repository). The configuration file here is located on your workstation, please do NOT confuse it with a config file for your project - that one is described above in the first section of this document.\nServer-side configuration These values are used to configure packit service. No need to bother with them, they serve as a documentation for us, packit service developers.\n   Key name Type Description     keytab_path string path to a Kerberos keytab file (requires fas_user to be set)   github_app_id string github app ID used for authentication   github_app_cert_path string path to a certificate associated with a github app   webhook_secret string when specified in a Github App settings, GitHub uses it to create a hash signature with each payload    "
},
{
	"uri": "https://packit.dev/testing-farm/",
	"title": "Testing Farm",
	"tags": [],
	"description": "",
	"content": " Testing Farm is Packit\u0026rsquo;s testing system. It is a containerized service for running tests. Test execution is configured via Flexible Metadata Format, according to the Metadata Specification.\nGo through the User Guide to get a quick start introduction. See the Examples section to get some more inspiration. The Support Matrix gives overview of what\u0026rsquo;s currently supported. In the Architecture section you will find information about Testing Farm\u0026rsquo;s internals.\nUser Guide The easiest way to get started is to use the tmt tool which will help you with the setup. Install the latest stable version directly from Fedora. See docs for more installation options.\nsudo dnf install -y tmt  Enable Testing In order to enable test execution simply include tests jobs in the .packit.yaml configuration:\njobs: - job: tests trigger: pull_request metadata: targets: - fedora-all  You can use fedora-development, fedora-stable or release specific targets such as fedora-31-x86_64 for test targets as well.\nSmoke Test Let\u0026rsquo;s enable a very simple smoke test which will run your application and check the exit code. Change to the root of the project git repository and use the tmt init command to initialize the metadata. For the simple smoke test we\u0026rsquo;ll be using the mini template:\n$ cd ~/git/did $ tmt init --template mini Tree '/home/psss/git/did' initialized. Applying template 'mini'. Directory '/home/psss/git/did/plans' created. Plan '/home/psss/git/did/plans/example.fmf' created.  Let\u0026rsquo;s see what the example plan contains:\n$ cat plans/example.fmf summary: Basic smoke test execute: script: tmt --help  Update the script line with the desired command line which should be executed as a test. It\u0026rsquo;s also possible to provide several commands to be executed in this way:\nsummary: Basic smoke test execute: script: - did --help - did --test  You might want to rename the plan to something more reasonable like smoke.fmf. When commiting new changes, make sure you include the special .fmf directory as well. It marks the root of the metadata tree and is needed for proper metadata detection.\n$ git add plans .fmf  Now just create a new pull request and you\u0026rsquo;re done!\nBeakerLib Test Let\u0026rsquo;s have a bunch of beakerlib tests stored in a git repository with their metadata. See the shared tests/selinux repository for an example of such tests. In order to enable these tests we will use tmt plan create to create the template for us:\n$ tmt init Tree '/home/psss/git/did' initialized. $ tmt plan create /plans/integration --template full Directory '/home/psss/git/did/plans' created. Plan '/home/psss/git/did/plans/integration.fmf' created.  Here\u0026rsquo;s what we get in the integration.fmf file:\nsummary: Essential command line features discover: how: fmf repository: https://github.com/psss/tmt prepare: how: ansible playbooks: plans/packages.yml execute: how: beakerlib  Let\u0026rsquo;s update the summary and repository link to point to the right location. The prepare section can be used to prepare the environment for testing. As we don\u0026rsquo;t have any extra requirements we can safely remove it for now. The resulting integration.fmf will look like this:\nsummary: Run integration tests for all SELinux components discover: how: fmf repository: https://src.fedoraproject.org/tests/selinux execute: how: beakerlib  That\u0026rsquo;s it. Now just commit the changes and create a new pull request. Make sure you include the special .fmf directory in the commit as well. It marks the root of the metadata tree and is needed for proper metadata detection.\n$ git add plans .fmf  Now let\u0026rsquo;s wait for the results from Packit directly in the pull request!\nRestart Testing The testing will be automatically started after an update to the pull request and successful copr build. To trigger retesting manually (can come handy in case of infrastructure issues for example), you can use the following comment in the pull request:\n/packit test  Support Matrix Currently only a subset of the metadata specification is implemented: It is possible to run BeakerLib tests and arbitrary shell commands. List of supported steps and implementations:\n Discover: fmf Prepare: ansible Execute: shell, beakerlib  See the Metadata Specification for a detailed description of individual test steps.\nTest Environment We currently support running tests in an x86_64 virtual machine only. The system is using qemu-kvm with hardware acceleration. You have full root access in the machine. The test environment currently cannot be easily changed.\nAdditional machine specs:\n RAM: 2 GB HDD: 4 GB  Debugging and Reproducing We are working on an easy way how to develop new tests, debug and reproduce issues for failed runs. Until that is ready, your best option is to spin up a new Fedora Docker container or run the Fedora Cloud Base qcow2 manually via qemu-kvm or libvirt. See the Worker section for details how to run the tool locally.\nExamples Get inspiration for a quick start from a couple of real-life examples!\nUsing Filters Use a custom filter in the discover step in order to choose relevant tests only:\ndiscover: how: fmf filter: \u0026quot;tier: 1\u0026quot; repository: https://src.fedoraproject.org/tests/selinux  Prepare Step The prepare step can be used to define how test environment should be prepared before testing. Provide one or more paths to ansible playbooks:\nprepare: how: ansible playbooks: - setup/packages.yml  Apache Test Here is an example of a simple integration test for the web server httpd and curl utility:\n/apache/smoke: execute: script: - dnf -y install httpd curl - systemctl start httpd - echo foo \u0026gt; /var/www/html/index.html - curl http://localhost/ | grep foo  Plan /apache/smoke defines only the execute step. Individual shell commands are provided as a list. Testing will fail if any of the commands returns a non-zero exit status.\nSystemd Tests Below you can find little bit more interesting example of a systemd test configuration:\n/systemd/smoke: summary: Basic set of quick smoke tests for systemd. discover: how: fmf filter: \u0026quot;tier: 1 \u0026amp; distro: rhel-8\u0026quot; repository: \u0026quot;https://github.com/systemd-rhel/tests\u0026quot; prepare: how: ansible playbooks: [setup/packages.yml] execute: how: beakerlib  This plan enables a set of Tier 1 tests from the shared systemd tests repository. The meaning of individual attributes is as follows:\n Summary — an optional but useful attribute describing high-level purpose of the plan. Discover — instructs to fetch tests from given repository and select relevant ones by provided filter. Prepare — specifies which ansible playbook should be applied to prepare environment for testing. Execute — defines that the beakerlib framework should be used for running the tests.  FMF Tests Here\u0026rsquo;s a real-life example of tests enabled for the fmf package. There are several plans defined under the plans directory. The smoke plan enables a super basic test checking availability of the fmf command:\nsummary: Just a basic smoke test execute: how: shell script: fmf --help  Plan features is used to execute all available beakerlib tests from the fmf repository:\nsummary: Essential command line features discover: how: fmf repository: https://github.com/psss/fmf execute: how: beakerlib  It is also possible to select only a subset of available tests. This is demonstrated by the docs plan. Use an fmf filter like tier:1 to select tests for execution. You can also reference a specific feature area instead:\nsummary: Ensure that documentation is present discover: how: fmf repository: https://github.com/psss/fmf filter: coverage:/stories/docs.* execute: how: beakerlib  See the stories directory to get some inspiration for organizing stories and requirements.\nIssues \u0026amp; RFEs If you have found an issue or have an RFE, please use Testing Farm\u0026rsquo;s general project to file an issue.\nArchitecture High Level Overview Testing Farm is a containerized application running on Kubernetes. It consists of 4 main components. It\u0026rsquo;s source code is located under the testing-farm organization on gitlab.com.\nCurrently Testing Farm is deployed on Centos CI Openshift, where it runs it\u0026rsquo;s components and uses the same cluster as the testing infrastructure. See section Test Environment for more information about the test environment.\nComponents API API is a REST API endpoint used for integration with other services. Packit Service uses this API to trigger tests. For each trigger request the API runs a Worker on the cluster as a separate pod.\nThe Console component uses it to get the logs of the Workers. Each trigger request MUST contain a unique pipeline ID, generated by the requester, which identifies the request and result and is used to access the console and testing artifacts.\nThe API is currently in version 0 and it is expected to change.\nThe source code of the API is located in the testing-farm/api project.\nConsole Is a React.js application that uses API\u0026rsquo;s console endpoint to access the Worker\u0026rsquo;s pod console. Currently it is the main entrypoint for a user. Packit users can access the console by clicking the Details link in the Github PR test results.\nConsole provides also a link to produced test artifacts.\nThe source code of the Console is located in the testing-farm/console project.\nArtifacts Artifacts component provides access to the artifact storage to the end users. Artifacts are stored on a persistent volume storage which is shared with all the workers. Artifacts are not accessed directly, but via the Console.\nThe source code of the Artifacts is located in the testing-farm/artifacts project.\nWorker Worker is a container image which runs the testing workloads. Each worker is run in a separate pod.\nThe worker can be easily run from your localhost and if it has access to /dev/kvm, it can run basically the same workloads as CI. We will use it in the future to provide a seamless experience to the end users to reproduce the tests on your localhost.\nIf you want to try out worker now, you can easily run some tests from a repository with FMF tests with the command bellow.\npodman run --device /dev/kvm quay.io/testing-farm/cruncher cruncher --git-url https://github.com/packit-service/hello-world --keep-instance  The option --keep-instance will keep the VM reserved and you will be presented in the worker logs how to connect to the machine via ssh.\nThe source code of the Worker is located in the testing-farm/cruncher project.\n"
},
{
	"uri": "https://packit.dev/docs/cli/create-bodhi-update/",
	"title": "create-bodhi-update",
	"tags": [],
	"description": "",
	"content": " Create a new bodhi update for the latest Fedora build of the upstream project.\nRequirements  Upstream git repository on Github. Packit config file placed in the upstream repository. Valid Fedora Kerberos ticket.  Tutorial  Place a config file for packit in the root of your upstream repository..\n Once the builds are done, you can run the create-update command. If you don\u0026rsquo;t specify the koji builds packit takes latest build.\n$ packit create-update --dist-git-branch f29 https://github.com/packit-service/packit.git Bodhi update FEDORA-2019-b72add0dcd: - https://bodhi.fedoraproject.org/updates/FEDORA-2019-b72add0dcd - stable_karma: 3 - unstable_karma: -3 - notes: \u0026quot;New upstream release 0.1.0\u0026quot;   Help Usage: packit create-update [OPTIONS] [PATH_OR_URL] Create a bodhi update for the selected upstream project PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Target branch in dist-git to release into. --koji-build TEXT Koji build (NVR) to add to the bodhi update (can be specified multiple times) --update-notes TEXT Bodhi update notes --update-type [security|bugfix|enhancement|newpackage] Type of the bodhi update -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/docs/how-to-source-git/",
	"title": "How to source-git?",
	"tags": [],
	"description": "",
	"content": " This is a practical introduction to source-git using a real example.\nIf you are interested in the theory behind source-git, please read the specification.\nLet\u0026rsquo;s create a source-git repo I choose systemd from Fedora 31 for this example.\nWhat do we need? 3 things:\n Systemd upstream repo. Fedora 31 dist-git repo of systemd. New local git repo.  Let\u0026rsquo;s set all of this up. We\u0026rsquo;ll start with an empty git repository:\n$ mkdir systemd-source-git $ cd systemd-source-git $ git init . Initialized empty Git repository in /home/tt/t/systemd-source-git/.git/  We\u0026rsquo;ll add fedora and upstream remotes, and then we\u0026rsquo;ll fetch them:\n$ git remote add upstream https://github.com/systemd/systemd.git $ git remote add fedora ssh://ttomecek@pkgs.fedoraproject.org/rpms/systemd.git $ git fetch -q upstream $ git fetch -q fedora  Systemd also has a dedicated repository with backports to the older releases. This is how systemd is packaged in Fedora.\n$ git remote add upstream-stable https://github.com/systemd/systemd-stable.git $ git fetch -q upstream-stable  We can start now When we open the Fedora 31 systemd spec file, we can see that upstream uses version 243.7. There\u0026rsquo;s a corresponding tag v243.7 in upstream-stable. We\u0026rsquo;ll start a new git branch in our repo named 2437-sg (sg as source-git):\n$ git switch -C 2437-sg v243.7 Switched to a new branch '2437-sg'  Right now we have the upstream history which lead to the 243.7 release. Alternatively we could just unpack the upstream tarball and have the history in a single commit.\nLayering downstream content on top of upstream Let\u0026rsquo;s get files from the fedora/f31 branch.\n$ git checkout fedora/f31 -- . $ git status On branch 2437-sg Changes to be committed: (use \u0026quot;git restore --staged \u0026lt;file\u0026gt;...\u0026quot; to unstage) modified: .gitignore new file: 0002-Revert-units-set-NoNewPrivileges-for-all-long-runnin.patch new file: 0998-resolved-create-etc-resolv.conf-symlink-at-runtime.patch new file: 20-grubby.install new file: 20-yama-ptrace.conf new file: 464a73411c13596a130a7a8f0ac00ca728e5f69e.patch new file: inittab new file: purge-nobody-user new file: sources new file: split-files.py new file: sysctl.conf.README new file: systemd-journal-gatewayd.xml new file: systemd-journal-remote.xml new file: systemd-udev-trigger-no-reload.conf new file: systemd-user new file: systemd.spec new file: triggers.systemd new file: yum-protect-systemd.conf  We have a bunch of new files from f31 branch in the root. We\u0026rsquo;ll move them now to the fedora/ directory:\n$ mkdir fedora $ mv $(git diff --name-only --cached) fedora/  and we should also clean our working tree:\n$ git reset HEAD . Unstaged changes after reset: M .gitignore $ git restore .gitignore  \u0026hellip;and commit the fedora content now:\n$ git add fedora  We don\u0026rsquo;t want to commit those patch files:\n$ git restore --staged fedora/0002-Revert-units-set-NoNewPrivileges-for-all-long-runnin.patch fedora/0998-resolved-create-etc-resolv.conf-symlink-at-runtime.patch fedora/464a73411c13596a130a7a8f0ac00ca728e5f69e.patch  We also (currently) have to remove them from the spec file. Packit will automatically generate patches from the additional commits and add them to the spec when generating a SRPM or proposing downstream update.\nWe can now commit the files in fedora/ directory:\n$ git commit -m 'add fedora packaging' [2437-sg 578bda8d7d] add fedora packaging 15 files changed, 3077 insertions(+) create mode 100644 fedora/.gitignore create mode 100755 fedora/20-grubby.install create mode 100644 fedora/20-yama-ptrace.conf create mode 100644 fedora/inittab create mode 100755 fedora/purge-nobody-user create mode 100644 fedora/sources create mode 100644 fedora/split-files.py create mode 100644 fedora/sysctl.conf.README create mode 100644 fedora/systemd-journal-gatewayd.xml create mode 100644 fedora/systemd-journal-remote.xml create mode 100644 fedora/systemd-udev-trigger-no-reload.conf create mode 100644 fedora/systemd-user create mode 100644 fedora/systemd.spec create mode 100644 fedora/triggers.systemd create mode 100644 fedora/yum-protect-systemd.conf  Applying downstream patches We are getting to the core of source-git: we work with code in it, not with patches. But first we need to instruct packit from which point in history start downstream patches. Add upstream_ref key into .packit.yaml:\nupstream_ref: 2437-sg-start  Commit and tag it:\n$ git commit -am \u0026quot;upstream_ref -\u0026gt; .packit.yaml\u0026quot; $ git tag 2437-sg-start HEAD  Now we can apply the downstream patches:\n$ git am fedora/464a73411c13596a130a7a8f0ac00ca728e5f69e.patch Applying: udev: use bfq as the default scheduler $ git am fedora/0002-Revert-units-set-NoNewPrivileges-for-all-long-runnin.patch Applying: Revert \u0026quot;units: set NoNewPrivileges= for all long-running services\u0026quot; $ git am fedora/0998-resolved-create-etc-resolv.conf-symlink-at-runtime.patch Applying: resolved: create /etc/resolv.conf symlink at runtime $ git log --oneline| head -n 3 5fc8885d47 resolved: create /etc/resolv.conf symlink at runtime 81c37ac6f6 Revert \u0026quot;units: set NoNewPrivileges= for all long-running services\u0026quot; d9f29507fe udev: use bfq as the default scheduler  (This is not the case for systemd, but) If the patches are not in git format you need to apply them with patch:\n$ patch -p1 --verbose --fuzz=0 \u0026lt;fedora/some-fix.patch $ git commit -am \u0026quot;some fix\u0026quot;  And that\u0026rsquo;s it, this is our source-git repo! You can check it out over here.\nWorking with source-git Run packit srpm and see that packit generates an upstream tarball plus downstream patches and puts everything along with a spec file into a SRPM. The same applies to propose-update, local-build or copr-build commands.\nAlternatively you can use --upstream-ref option instead of putting the upstream_ref into .packit.yaml\nWrap up As you can see, it is a lot of work to create the source-git repo. We are planning on automating it — creating a dedicated command in packit.\nWe also have a bunch of packit code related to source-git already done, but the overall experience is not done end-to-end.\n"
},
{
	"uri": "https://packit.dev/docs/cli/propose-update/",
	"title": "propose-update",
	"tags": [],
	"description": "",
	"content": " This is a detailed documentation for the update functionality of packit. The command creates a new pull request in Fedora using a selected or latest upstream release.\nRequirements  Upstream git repository on Github. Upstream release (read, git tag) where version in spec file is equivalent to the name of the git tag. Packit config file placed in the upstream repository. Spec file present in the upstream repository and is correct in a given release. Pagure API tokens for Fedora Dist-git. Github API token. Valid Fedora Kerberos ticket.  Tutorial  Place a file called .packit.yaml or packit.yaml in the root of your upstream repository.\n The configuration is described in this document. Please get inspired from an existing config in colin project.  Place a spec file into your upstream project (and make sure that specfile_path in the config has a correct value).\n This spec file will be then used to perform the update in Fedora. When you create a new upstream release, you should also update the spec file. Once your upstream release is out (and the spec file is really up to date), you can use packit to release it into Fedora.  Create a new upstream release. The spec file needs to be included in the ref for upstream release, because packit checks out the tag for the upstream release before copying files downstream.\n Starting with packit 0.5.2 and later, you only need to set a single token to interact with dist-git. You needed two in the past. Please populate your local config for packit so it can talk to the remote services:\n  # you can obtain the token over here: https://github.com/settings/tokens github_token: 123 # and this one right here: https://src.fedoraproject.org/settings#nav-api-tab pagure_user_token: 456   Once you have performed the upstream release (and the new archive is up), run packit propose-update in a working directory of your upstream repository:\n$ git clone https://github.com/user-cont/colin.git $ cd colin $ packit propose-update using \u0026quot;master\u0026quot; dist-git branch syncing ./colin.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/c/colin/colin-0.3.0.tar.gz 100%[=============================\u0026gt;] 3.18M eta 00:00:00 downloaded archive: /tmp/tmpaanrpgjz/colin-0.3.0.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/colin/pull-request/4   Help Usage: packit propose-update [OPTIONS] [PATH_OR_URL] [VERSION] Release current upstream release into Fedora PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory VERSION argument is optional, the latest upstream version will be used by default Options: --dist-git-branch TEXT Target branch in dist-git to release into. --dist-git-path TEXT Path to dist-git repo to work in. Otherwise clone the repo in a temporary directory. --local-content Do not checkout release tag. Use the current state of the repo. --force-new-sources Upload the new sources also when the archive is already in the lookaside cache. -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/docs/cli/srpm/",
	"title": "srpm",
	"tags": [],
	"description": "",
	"content": " Create a SRPM of the present content in the upstream repository.\nBy default, packit uses git describe --tags --match '*.*' to create a unique version of the snapshot and git archive -o \u0026quot;{package_name}-{version}.tar.gz\u0026quot; --prefix \u0026quot;{package_name}-{version}/\u0026quot; HEAD to create a tarball with upstream sources.\nYou can override the archive and version commands in packit.yaml, e.g. this is what we use in ogr, a library which packit is using:\ncreate_tarball_command: [\u0026quot;python3\u0026quot;, \u0026quot;setup.py\u0026quot;, \u0026quot;sdist\u0026quot;, \u0026quot;--dist-dir\u0026quot;, \u0026quot;.\u0026quot;] current_version_command: [\u0026quot;python3\u0026quot;, \u0026quot;setup.py\u0026quot;, \u0026quot;--version\u0026quot;]  Requirements  Upstream project is using git. Packit config file placed in the upstream repository.  Tutorial  Place a config file for packit in the root of your upstream repository..\n Now we would generate a SRPM for ogr project:\n$ packit srpm Version in spec file is \u0026quot;0.0.3\u0026quot;. SRPM: /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm  We can now build the package:\n$ rpmbuild --rebuild /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm Installing /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.95VZ3c + umask 022 + cd /home/tt/rpmbuild/BUILD + cd /home/tt/rpmbuild/BUILD + rm -rf ogr-0.0.4.dev11+gc9956c9.d20190318 + /usr/bin/gzip -dc /home/tt/rpmbuild/SOURCES/ogr-0.0.4.dev11+gc9956c9.d20190318.tar.gz + /usr/bin/tar -xof - + STATUS=0 ... Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.aYyTMP ... Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.fotlPv ... + exit 0 Provides: python3-ogr = 0.0.4.dev11+gc9956c9.d20190318-1.fc29 python3.7dist(ogr) = 0.0.4.dev11+gc9956c9.d20190318 python3dist(ogr) = 0.0.4.dev11+gc9956c9.d20190318 Requires(rpmlib): rpmlib(CompressedFileNames) \u0026lt;= 3.0.4-1 rpmlib(FileDigests) \u0026lt;= 4.6.0-1 rpmlib(PartialHardlinkSets) \u0026lt;= 4.0.4-1 rpmlib(PayloadFilesHavePrefix) \u0026lt;= 4.0-1 Requires: python(abi) = 3.7 python3.7dist(gitpython) python3.7dist(libpagure) python3.7dist(pygithub) python3.7dist(python-gitlab) Checking for unpackaged file(s): /usr/lib/rpm/check-files /home/tt/rpmbuild/BUILDROOT/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.x86_64 Wrote: /home/tt/rpmbuild/RPMS/noarch/python3-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.noarch.rpm + exit 0   Help Usage: packit srpm [OPTIONS] [PATH_OR_URL] Create new SRPM (.src.rpm file) using content of the upstream repository. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --output FILE Write the SRPM to FILE instead of current dir. --remote TEXT Name of the remote to discover upstream project URL, If this is not specified, default to origin. --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). -h, --help Show this message and exit.  As you can see, it is possible to create SRPM for source-git repositories as well. Just add an --upstream-ref option to the packit command.\nIf you have a git tag 0.1.0 specifying the upstream code, just run packit srpm --upstream-ref 0.1.0 to create an SRPM file. It will create an archive from the given upstream reference (0.1.0) and following commits will be added as downstream patches.\nJust make sure, that you apply all the patches in the specfile. (Packit only adds the patches after the sources.) You can use a following setup:\n Define the macro on top of the specfile:\n%global num_patches %{lua: c=0; for i,p in ipairs(patches) do c=c+1; end; print(c);}  Apply the patches in the %prep part:\n%if %{num_patches} git init git config user.email \u0026quot;noreply@example.com\u0026quot; git config user.name \u0026quot;John Foo\u0026quot; git add . git commit -a -q -m \u0026quot;%{version} baseline.\u0026quot; # Apply all the patches. git am %{patches} %endif   "
},
{
	"uri": "https://packit.dev/docs/cli/sync-from-downstream/",
	"title": "sync-from-downstream",
	"tags": [],
	"description": "",
	"content": " This is a detailed documentation for the downstream sync functionality of packit. The command creates a new pull request in upstream repository using a selected branch (master by default) from Fedora dist-git repository.\nRequirements  Fedora dist-git repository. Packit config file placed in the upstream repository. Pagure API tokens for Fedora Dist-git. Github API token.  Tutorial  Starting with packit 0.5.2 and later, you only need to set a single token to interact with dist-git. You needed two in the past. Please populate your local config at ~/.config/packit.yaml for packit so it can talk to the remote services:\n# you can obtain the token over here: https://github.com/settings/tokens github_token: 123 # and this one right here: https://src.fedoraproject.org/settings#nav-api-tab pagure_user_token: 456  Files which are synced are mentioned in .packit.yaml as synced_files value.\n Once you want to sync Fedora dist-git repo into the upstream repo, run packit sync-from-downstream in a working directory of your upstream repository:\n  $ git clone https://github.com/user-cont/colin.git $ cd colin $ packit sync-from-downstream upstream active branch master Cloning repo: https://src.fedoraproject.org/rpms/colin.git -\u0026gt; /tmp/tmph9npe78e using master dist-git branch syncing /tmp/tmph9npe78e/colin.spec PR created: https://api.github.com/repos/phracek/colin/pulls/3  packit sync-from-downstream \u0026ndash;help Usage: packit sync-from-downstream [OPTIONS] [PATH_OR_URL] Copy synced files from Fedora dist-git into upstream by opening a pull request. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Source branch in dist-git for sync. --upstream-branch TEXT Target branch in upstream to sync to. --no-pr Pull request is not create. --fork / --no-fork Push to a fork. --remote-name TEXT Name of the remote where packit should push. if this is not specified, it pushes to a fork if the repo can be forked. -h, --help Show this message and exit.  "
},
{
	"uri": "https://packit.dev/posts/february-2020/",
	"title": "February 2020",
	"tags": [],
	"description": "",
	"content": " Week 6 Both Packit and Packit Service pre-commit hooks were updated to include prettier and setup-cfg-fmt, in order to have a more consistent formatting of markup, YAML, JSON and setup.cfg files.\nIt became easier for developers to build the Packit base image locally, and tests in Zuul were configured to run on Fedora 31.\nPackit learned how to look for RPM spec files on its own, so specifying specfile_path in the configuration is not mandatory anymore. Packit will recursively search the tree and use the first spec file found.\nThe Redis pod in Packit Service uses an up to date image now, based on Fedora 31. Kudos to hhorak for the help!\nWeek 7 The default configuration generated by Packit has test jobs enabled from now on. This should simplify configuring Packit in new repositories.\nFixed a bug which was causing SRPM-build failures in Packit Service for projects which had their spec files stored in a subdirectory.\nAs a result of keys.fedoraproject.org being turned off, Packit now tries a list of GPG keyservers when downloading keys to check commit signatures.\nWhen enabling Packit Service for new GitHub repositories, instead of checking if the requester is a Fedora packager, we\u0026rsquo;ll check if they signed the Fedora Project Contributor Agreement.\nWhile proposing an update to Fedora, Packit Service will report a failure now when there are no releases found in the upstream GitHub repository.\nTest results became serializable, we will not block when no test results are received, and Packit Service received some initial code to enable using PostgreSQL as a data backend.\nWeek 8 Postgresql database was introduced in production environment to improve performance and enable implementation of new features, e.g. storing logs to reduce amount of messages sent directly to pull request (#406), (#420).\nCleanup in configuration files was performed, so no longer needed values were removed from .packit.yaml (#709). User experience was improved by adding new --upstrem-ref option to copr-build command in command-line interface (#718) and making error reporting more robust by adding new fedpkg clones related error message (#714).\nFollowing bugs were fixed: - bug in copr-build command fixed (#713) - get_local_package_config() duplicate entries in \u0026lsquo;directories\u0026rsquo; bug fixed (#715)\nWeek 9 Dist-git patches are newly applied with -p1 (#730). Packit specfile code was improved (#736), (#734). Fedora-32 was added to \u0026lsquo;fedora-all\u0026rsquo; and \u0026lsquo;fedora-development\u0026rsquo; aliases (#731). Documentation was improved by adding links to user configuration (#726).\nPackit-service was adjusted, so we don\u0026rsquo;t need metadata for copr build (#431). Ansible playbooks in deployment repo were adjusted to use the same playbooks in Zuul and locally (#429). Handlers were moved to separate module(#426) and build-helper classes were refactored (#424).\nBug related to incorrect pull-request filtering was fixed (#441).\n"
},
{
	"uri": "https://packit.dev/posts/january-20/",
	"title": "January 2020",
	"tags": [],
	"description": "",
	"content": " Week 1 packit  Correctly updates version on srpm build. (#642) Downloads all URL sources before srpm build. (#643)  packit service  Runs on Fedora 31. (#303, #304) Correctly checks list of whitelisted repositories when issue comment is added. (#309)  Week 2 packit  Incorporates lots of SRPM related improvements. (#646, #650, #651, #652, #653) Better handles when Copr owner is not set. (#648)  packit service  Fixes SRPM exceptions/errors handling. (#311, #317) Has loading of config fixed. (#318)  Week 3 packit  Uses Marshmallow for configuration schema. (#657) Is able to build in Koji from upstream/source-git. (#658) Doesn\u0026rsquo;t download remote sources when \u0026ldquo;sources\u0026rdquo; path exists in upstream. (#659) Configuration file allows list syntax in action commands. (#663) Configuration can use a new option to exclude paths from patching. (#666) Has few less bugs. (#660, #661, #664, #667)  packit service  Uses Marshmallow for configuration schema. (#320) Runs build for test job even when it\u0026rsquo;s not explicitly configured. (#324) Reports invalid or missing packit config. (#328) Status workflow has been changed and simplified. (#338) Minor fixes. (#323, #326, #329, #331, #335, #336)  Week 4 packit  0.8.1 has been released. CLI has bash auto completion. (#654) Few bugs have been squashed. (#668, #670, #676, #677, #678, #680, #682)  packit service  More checks messages have been unified. (#355) One more testing-farm status is now shown before the tests are submitted. (#343) No-fmf scenario has better messages. (#362) Minor fixes and improvements. (#339, #340, #342, #345, #346, #347, #348, #352, #353, #350, #357, #358, #361, #364)  Week 5 packit  CLI has a new command for local build. (#687) Logs less. (#685)  packit service  Minor fixes and improvements. (#365, #371, #373, #376)  "
},
{
	"uri": "https://packit.dev/posts/december-19/",
	"title": "December 19",
	"tags": [],
	"description": "",
	"content": " Week 49 ogr \u0026amp; packit  ogr-0.9.0 has been released greatly restructured. (#291) packit status (CLI) now shows also latest Copr builds. (#579) Target aliases (currently fedora-development, fedora-stable, fedora-all) can now be used in the packit config file. (#619) When doing a new update in Fedora dist-git, packit now by default creates a new pull request instead of pushing directly to dist-git. (#622)  packit service  Does not set test checks when tests are not configured. (#275) Supports target aliases and dist-git branches aliases. (#277, #285) Nicely formats errors from OpenShift API. (#283) Runs Copr build when user adds a /packit build comment into a PR. (#290)  Week 50 packit  If there is no upstream_package_name/downstream_package_name given in .packit.yaml, they now default to the name of the GitHub repo. (#624) If no jobs are defined in .packit.yaml packit by default runs build job on fedora-stable targets and propose_downstream on fedora-all branches. (#625) build command has nicer output. (#630) Smaller fixes. (#630, #636)  packit service  Creates a new issue when propose-update fails. (#300) Better reports failed submitting of a Copr build. (#301)  "
},
{
	"uri": "https://packit.dev/posts/week-44-48-19/",
	"title": "Week 44-48 (November) 2019",
	"tags": [],
	"description": "",
	"content": " With this blog post we\u0026rsquo;d like to continue with the idea of openly communicating changes in Packit. Since most of the developers use Packit as the GitHub App (which uses code from this repository - Packit Service), this blog will be about changes in all the parts, i.e. the GitHub App, the Packit Service and Packit itself.\nContinuous Deployment (CD) At the moment the workflow is that one of us manually triggers production container image build at the end of a week. This image is then automatically deployed into our production instance of the service over a weekend (Sun/Mon night) so that everyone can start a week with all the amazing stuff we added the previous week. In case an issue makes it through our staging instance into production uncaught, we can easily rollback on Monday. The same person also writes down what\u0026rsquo;s changed in Packit (service/app) since previous deployment.\nChanges in production (since the end of November) Previous post is almost half a year old so we won\u0026rsquo;t list all the changes since then, but only since last deployment, i.e. since end of December.\nPackit Previous deployment was running packit-0.7.1. We haven\u0026rsquo;t released a newer version since then, but in the service we install Packit from the Git repository (we have a separate stable git branch for our production deployment). From the most visible changes, Packit now:\n better handles Create-archive action is able to work in a repo with detached head logs output from subprocesses in realtime syncs config file and spec file by default in Propose-update action hadles patches with undecodable chars  Packit Service Now:\n better reports Copr builds  uses separate commit status for srpm build and every chroot clears test farm commit statuses when new build is triggered better handles failed Copr builds  gracefully handles no config file in the repo better handles when no (copr build) targets are specified in config file better checks whitelist of users does not create duplicate tickets in our notification repo when a new user install the app  Changes not visible to end users:\n using Requre for integration/E2E tests Fedora messaging consumer part of the service has been improved and moved to separate repo/image using FAS instead of Fedora Badges for checking whether a user is Fedora packager many improved logs many bugs squashed lot\u0026rsquo;s of code refactored  "
},
{
	"uri": "https://packit.dev/faq/",
	"title": "FAQ",
	"tags": [],
	"description": "",
	"content": " Can I use the packit service as soon as I install it into my repository? Thanks for your interest in Packit Service! In order to start using the service you need to be whitelisted, which is an action to be done by us. Once we put you on the whitelist, we\u0026rsquo;ll get in touch with you. We are now on-boarding Fedora contributors (with a Fedora Account System account).\nCan I use packit service for any GitHub repository? Since packit service builds your PRs in Fedora COPR build service, by using Packit-as-a-service, your software needs to comply with COPR rules. If any of these points are violated, we\u0026rsquo;ll remove the builds and may put you on a blacklist so you won\u0026rsquo;t be able to use the service again.\nHow can I contact you? If you encounter a problem while using Packit-as-a-service, please open an upstream issue. In case of any other questions, feel free to contact us:\n freenode #packit user-cont-team@redhat.com  Why do I have to maintain .packit.yaml and a spec file upstream? We are working on simplifying the .packit.yaml so it\u0026rsquo;s as small as possible. We will also handle all potentially backward incompatible changes of .packit.yaml. Spec file can be downloaded (see specific question below) from Fedora Pagure instead of having it included in the upstream repository.\nBut what are the benefits? Packit makes it trivial to run your project as part of an OS. It provides feedback to your project at the time when the changes are being developed so you can fix incompatible code when you are working on it, not when it\u0026rsquo;s already released. When you push commits to a pull request, you\u0026rsquo;ll get RPM build and test results right away.\nWhy Fedora? We\u0026rsquo;ve started with Fedora Linux because we work for Red Hat and we ❤ Fedora.\nHow is Packit different from other services? Packit connects the existing services (Copr, Pagure, Koji, Bodhi) together.\nCan we use Packit with Gitlab? Packit service is closely tied to GitHub right now because most of the projects are hosted on GitHub. Let us know if you\u0026rsquo;d like to see Gitlab support.\nHow can I download RPM spec file if it is not part of upstream repository? If you do not want to have the RPM spec file in your upstream repository, you can download it in actions section.\nAdd actions section to your packit.yaml configuration file and download the spec file in a hook post_upstream_clone. Packit service has a limited set of commands available so please use wget or curl.\nThe configuration file with downloading the RPM spec file now looks like this:\nspecfile_path: packit.spec synced_files: - packit.spec - .packit.yaml upstream_package_name: packitos downstream_package_name: packit actions: post-upstream-clone: \u0026quot;wget https://src.fedoraproject.org/rpms/packit/raw/master/f/packit.spec\u0026quot;  I have a template of a spec file in my repo: can packit work with it? Yes!\nThe solution is, again, actions and hooks. Just render the spec after the upstream repo is cloned:\nspecfile_path: my-project.spec upstream_package_name: my-project-src downstream_package_name: my-project actions: post-upstream-clone: \u0026quot;make generate-spec\u0026quot;  Where the \u0026ldquo;generate-spec\u0026rdquo; make target could look like this:\ngenerate-spec: sed -e 's/@@VERSION@@/$(VERSION)/g' my-project.spec.template \u0026gt;my-project.spec  As a practical example, cockpit-podman project is using this functionality.\nCan I use CentOS Stream with packit service? Yes, you can! It\u0026rsquo;s very simple, just add centos-stream-x86_64 as a target for the copr_build job:\njobs: - job: copr_build trigger: pull_request metadata: targets: - centos-stream-x86_64  After adding tests I see error \u0026lsquo;No FMF metadata found.\u0026rsquo; If you encounter this error when running tests via Testing Farm, it means you forgot to initialize the metadata tree with fmf init and include the .fmf directory in the pull request. See Testing Farm documentation for more information.\n"
},
{
	"uri": "https://packit.dev/docs/cli/copr-build/",
	"title": "copr-build",
	"tags": [],
	"description": "",
	"content": " Submit a Copr build of the present content in the upstream repository.\nRequirements  Upstream git repository on Github. Packit config file placed in the upstream repository. ~/.config/copr  Tutorial  Place a config file for packit in the root of your upstream repository.\n The command below would create a SRPM from the present content of a repo and perform copr-cli build with it. If you need to specify a project name/owner or chroots, see the options in help.\n$ cd my/ustream/project/ $ packit copr-build   Help Usage: packit copr-build [OPTIONS] [PATH_OR_URL] Build selected upstream project in COPR. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory. Options: --nowait Don't wait for build --owner TEXT Copr user, owner of the project. (defaults to username from ~/.config/copr) --project TEXT Project name to build in. Will be created if does not exist. (defaults to 'packit-cli-{repo_name}-{branch/commit}') --targets TEXT Comma separated list of chroots to build in. (defaults to 'fedora-rawhide-x86_64')  "
},
{
	"uri": "https://packit.dev/docs/cli/",
	"title": "Packit CLI Commands",
	"tags": [],
	"description": "",
	"content": " build create-bodhi-update propose-update srpm sync-from-downstream copr-build  "
},
{
	"uri": "https://packit.dev/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "Packit Packit provides tooling and automation to integrate upstream open source projects into Fedora operating system. Packit project is composed of two main components:\n packit, a CLI tool, which you can install locally and start using right away.\n Packit-as-a-Service, a GitHub app — it can provide you feedback on how is your project integrated with Fedora Operating System.\n  Feel free to jump into the guide for using packit.\nUpstream repository https://github.com/packit-service/packit\nContact You can find us at Freenode IRC channel #packit, or feel free to create an issue in any of our GitHub projects.\nWe are also available on this e-mail: user-cont-team@redhat.com.\nThe key principles of packit  Packit aims to make things easy and right. But if the default behavior is not the right for you, there is still a way around, but may not be that simple. For example you can use actions to replace default packit\u0026rsquo;s behavior with a script of yours.\n Reuse existing tools and services where it makes sense: don\u0026rsquo;t reinvent the wheel.\n You can consume packit in two forms:\n Packit tool can run on your laptop and you run commands you want. Packit service reacts to events and performs actions which you defined in your packit.yaml.  We don\u0026rsquo;t break backwards compatibility just like that.\n Packit has a deprecation policy:\n We can mark a behaviour as deprecated. Deprecated content can be removed or changed after at least 3 minor releases. Deprecated content is advertised in our changelog, printed in terminal or tracked in your issue tracker.  We care about artifacts which Fedora supports: at the moment it\u0026rsquo;s RPMs, modules and container images.\n Our initial focus is solely on RPMs.  Packit respects Fedora guidelines.\n We want latest content in Fedora Rawhide, but only if it works (the new content can be built and tests are passing).\n Any task done by the automation system must be able to be performed by a human when that is required. Packit service must be capable of recovering from such situation.\n Packit developers must be able to iterate on all parts packit (testing a change, merging a change, deploying to production) at a pace of at least every two weeks. To accomplish this, the release and validation processes are completely automated.\n All the tests are passing in CI systems for master branches for all our projects. No excuses.\n Contributions to packit must be possible by any developer, maintainer, tester, or other engineer. Any Fedora developer or tester should be able to reproduce a bot locally on their machine, given appropriate credentials.\n  Why packit?  Our intent is to bring downstream and upstream communities closer: provide feedback from downstream to upstream. (e.g. \u0026ldquo;Hello \u0026lt;upstream project Y\u0026gt;, your newest release doesn\u0026rsquo;t work in Fedora Rawhide, it breaks \u0026lt;Z\u0026gt;, here is a link to logs.\u0026rdquo;)\n We want to only merge, build and compose components which integrate well with the rest of the operating system. The biggest impact of such behavior will be on Fedora Rawhide and when working on a new Fedora release.\n Automatically pull and validate new upstream releases. This can be a trivial thing to do, why should maintainers waste their times on work which can be automated.\n Developing in dist-git is cumbersome. Editing patch files and moving tarballs around is not fun. Why not working with the source code itself? With source-git, you\u0026rsquo;ll have upstream git history and the dist-git content combined in a single repository.\n Let\u0026rsquo;s use modern development techniques such as pull requests, code review, modern git forges, automation and continuous integration. We have computers to do all the mundane tasks. Why we, as humans, should do such work?\n We want dist-git to be \u0026ldquo;a database of content in a release\u0026rdquo; rather a place to do actual work. On the other hand, you\u0026rsquo;ll still be able to interact with dist-git the same way. We are not taking that away. Source-git is meant to be the modern, better alternative.\n  DevConf.cz \u0026ldquo;Auto-maintain your package\u0026rdquo; talk.\n"
},
{
	"uri": "https://packit.dev/posts/packit-042/",
	"title": "Packit 0.4.2",
	"tags": [],
	"description": "",
	"content": "Another relase after a month since 0.4.1, this time mostly with bug fixes.\nWe\u0026rsquo;ve been busy polishing our Github App recently, therefore we had no resources for new features.\nSee CHANGELOG for more details.\n"
},
{
	"uri": "https://packit.dev/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://packit.dev/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]